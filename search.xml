<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图片小爬虫</title>
      <link href="%E5%B0%8F%E7%88%AC%E8%99%AB/"/>
      <url>%E5%B0%8F%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>申明：以下爬虫只是作为学习技术记录，其目的只是了解相关技术，并未将其作为工具进行使用</p></blockquote><blockquote><p>引言：这些爬虫只是单纯的通过图片链接进行爬取，因此这些图片都是经过处理过的，图片一般很小，像素点和清晰度都是我不能接受的，因此对于图片，在下一般是通过提供下载功能的图片网站进行收集，遇到喜欢的随手下一下。</p><p>因为以前写过一点点，因此这份小代码就直接搬运了以前的代码进行了修改，花费的时间不多。</p></blockquote><blockquote><p>这些代码还有很多地方可以完善，同时有很多东西是可以深入学习的，比如jsoup的selector，css选择器，java中Map,Map的升级，集合等等，以及模块化编程，代码优化，算法思考等等，都说略懂皮毛，一想到这些就知道连皮都还没懂</p></blockquote><h2 id="唯美女生网站"><a href="#唯美女生网站" class="headerlink" title="唯美女生网站"></a>唯美女生网站</h2><ul><li>网址：<a href="https://www.wmgirl.com/">https://www.wmgirl.com/</a></li></ul><p><img src="https://remmeiko.gitee.io/img-bed/crawler/image-20210428212817044.png" alt="唯美女生"></p><ul><li><p>主要代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>        Document pagedocu <span class="token operator">=</span> <span class="token function">requestDoc</span><span class="token punctuation">(</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token string">"https://www.wmgirl.com/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Classification-->分类</span>        Elements Classifications1 <span class="token operator">=</span> pagedocu<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token string">".nav.navbar-nav.fright.nav-cate-pc.navbar-nav-box>li"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Elements Classifications2 <span class="token operator">=</span> pagedocu<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token string">".row>.col-md-2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        LinkedHashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> ClassificationMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取小姐姐分类 添加至Map字典之中</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Element Classification<span class="token operator">:</span>Classifications1<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ClassificationMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>Classification<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Classification<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"href"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Element Classification<span class="token operator">:</span>Classifications2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ClassificationMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>Classification<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Classification<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"href"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 从字典中去除无关选项</span>        ClassificationMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"首页"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ClassificationMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"关于"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ClassificationMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"浏览历史"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ClassificationMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"周杰伦新歌"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// System.out.println(ClassificationMap);</span>        <span class="token comment" spellcheck="true">// 选择下载的类型</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> TypeData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>String key<span class="token operator">:</span>ClassificationMap<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"类型"</span><span class="token operator">+</span>i<span class="token operator">+</span><span class="token string">": "</span><span class="token operator">+</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            TypeData<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ClassificationMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"请选择小姐姐类型(输入标号)："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Scanner in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> choice <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 访问类型对应的网址</span>        String ClassificationUrl <span class="token operator">=</span> <span class="token string">"https://www.wmgirl.com"</span><span class="token operator">+</span>TypeData<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>choice<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//System.out.println(ClassificationUrl);</span>        pagedocu <span class="token operator">=</span> <span class="token function">requestDoc</span><span class="token punctuation">(</span><span class="token function">request</span><span class="token punctuation">(</span>ClassificationUrl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 提取网址中的每一组小姐姐对应的网址</span>        Elements GroupUrls <span class="token operator">=</span> pagedocu<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token string">".waterfall.waterfall .item"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> GroupUrlsList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 得到每组图片的标题图片的Url</span>        <span class="token comment" spellcheck="true">/*for(Element PictureUrl :PictureUrls) {            Urls.add(PictureUrl.select(".item-content.tab-content a img").attr("src"));        }*/</span>        ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> GroupUrlsList2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Element GroupUrl<span class="token operator">:</span>GroupUrls<span class="token punctuation">)</span> <span class="token punctuation">{</span>            GroupUrlsList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>GroupUrl<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token string">".item-content.tab-content a"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"href"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>String data <span class="token operator">:</span> GroupUrlsList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            String GroupUrl <span class="token operator">=</span> <span class="token string">"https://www.wmgirl.com"</span><span class="token operator">+</span>data<span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请求目标主页Url:"</span><span class="token operator">+</span>GroupUrl<span class="token punctuation">)</span><span class="token punctuation">;</span>            pagedocu <span class="token operator">=</span> <span class="token function">requestDoc</span><span class="token punctuation">(</span><span class="token function">request</span><span class="token punctuation">(</span>GroupUrl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 获取最终图片下载地址</span>            Elements FinalUrls <span class="token operator">=</span> pagedocu<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token string">".picbox>div"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> FinalUrlsList <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第"</span><span class="token operator">+</span><span class="token punctuation">(</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"组图片："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> numflag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>Element FinalUrl <span class="token operator">:</span> FinalUrls<span class="token punctuation">)</span> <span class="token punctuation">{</span>                FinalUrlsList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>FinalUrl<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token string">"img"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"src"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"下载的第"</span><span class="token operator">+</span>numflag<span class="token operator">+</span><span class="token string">"张图片网址："</span><span class="token operator">+</span>FinalUrl<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token string">"img"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"src"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                numflag<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//下载</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--------------------------------------------------------------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始下载....."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">Download</span><span class="token punctuation">(</span>FinalUrlsList<span class="token punctuation">,</span>TypeData<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>choice<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--------------------------------------------------------------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre></li><li><p>演示画面</p><blockquote><p>JDK环境：jdk-14</p><ul><li>链接：<a href="https://pan.baidu.com/s/17878POrKEYydtp5AzT31ww">https://pan.baidu.com/s/17878POrKEYydtp5AzT31ww</a><br>提取码：1245 </li></ul><p>JDK1.8环境可能无法运行，可以下载上面的jdk-14然后修改环境变量</p></blockquote></li></ul><p><img src="https://remmeiko.gitee.io/img-bed/crawler/image-20210428213227425.png" alt="image-20210428213227425"></p><ul><li><p>代码存在的问题(有时间的可以自己改一下)</p><ul><li>1）未设置代理ip和代理池—&gt;因此采用了延时爬取，每一次爬取过后会停止十秒左右</li><li>2）下载的图片是被处理过的</li><li>3）对于爬虫异常未作处理，健壮性弱</li><li><ol start="4"><li>  代码是怎么方便怎么来，菜鸡鸡中鸡水平，图一乐呵</li></ol></li></ul></li><li><p>测试爬取结果(注意图片大小)</p><p><img src="https://remmeiko.gitee.io/img-bed/crawler/image-20210428214841591.png" alt="image-20210428214841591"></p></li><li><p>百度云盘</p><blockquote><p>已经打包成jar文件，可以下载jar文件查看完整代码，其中使用到的jar依赖包也可以看到</p></blockquote><ul><li>链接：<a href="https://pan.baidu.com/s/1-E8oyDKPttuX7bifh1VhhA">https://pan.baidu.com/s/1-E8oyDKPttuX7bifh1VhhA</a>     提取码：1234 </li><li>运行：安装java环境后，打开cmd，输入命令即可<ul><li>java -jar .\wmGirls.jar</li></ul></li></ul></li></ul><h2 id="必应壁纸"><a href="#必应壁纸" class="headerlink" title="必应壁纸"></a>必应壁纸</h2><blockquote><p>这份代码和上面是一样的，准确来讲上面的代码是将下面的代码改了一下，下面的代码要更早一点面世</p><p>必应壁纸是提供了下载功能的，所以如果是学习的话采用上面的代码学习即可，感谢必应作者(攻城狮小哥一枚)为我们提供的必应壁纸，下面的代码仅仅学习使用，不用做爬取工具。</p></blockquote><ul><li>网址:<a href="https://bing.ioliu.cn/">https://bing.ioliu.cn</a></li></ul><p><img src="https://remmeiko.gitee.io/img-bed/crawler/image-20210429004444571.png" alt="image-20210429004444571"></p><ul><li>部分代码</li></ul><pre class=" language-java"><code class="language-java">        String StrUrl <span class="token operator">=</span> <span class="token string">"https://bing.ioliu.cn"</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> startNum<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> startNum <span class="token operator">+</span> NumNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//请求主页时候挂起5s</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"正在请求主页中...."</span> <span class="token operator">+</span> <span class="token string">"请等待5s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            HttpEntity PageHome <span class="token operator">=</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token string">"https://bing.ioliu.cn/?p="</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请求成功,接下来开始下载这一页图片..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//请求的html文档</span>            String Pagehtml <span class="token operator">=</span> EntityUtils<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>PageHome<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Document pagedocu <span class="token operator">=</span> Jsoup<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>Pagehtml<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//拿取请求页面的图片相关数量信息</span>            String Numdiv <span class="token operator">=</span> pagedocu<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token string">".page span"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//结果是1 / 133 字符串</span>            String<span class="token punctuation">[</span><span class="token punctuation">]</span> num <span class="token operator">=</span> Numdiv<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//以空格分割成字符串数组</span>            <span class="token comment" spellcheck="true">//拿取图片的相关其他信息存储在数组Names中</span>            ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> Names <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Elements Namedivs <span class="token operator">=</span> pagedocu<span class="token punctuation">.</span><span class="token function">getElementsByClass</span><span class="token punctuation">(</span><span class="token string">"description"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Element Namediv <span class="token operator">:</span> Namedivs<span class="token punctuation">)</span> <span class="token punctuation">{</span>                String name <span class="token operator">=</span> Namediv<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token string">"h3"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                String<span class="token punctuation">[</span><span class="token punctuation">]</span> Name <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\\("</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//设置动态数组存储url</span>            ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> Urls <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//获取url所在的所有列表</span>            Elements containers <span class="token operator">=</span> pagedocu<span class="token punctuation">.</span><span class="token function">getElementsByClass</span><span class="token punctuation">(</span><span class="token string">"item"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Element container <span class="token operator">:</span> containers<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Elements item <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token string">".card.progressive"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Urls<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"href"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//写入文件中 //父路径</span>            File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"C:\\Users\\31327\\Desktop"</span><span class="token punctuation">,</span> <span class="token string">"必应壁纸"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//判断文件夹是否存在</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>file<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                file<span class="token punctuation">.</span><span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>String str <span class="token operator">:</span> Urls<span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">//url中需要替换的目标字符串</span>                String strobeNam <span class="token operator">=</span> <span class="token string">"home_"</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>                str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>strobeNam<span class="token punctuation">,</span> <span class="token string">"download"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"图片网址是:"</span> <span class="token operator">+</span> StrUrl <span class="token operator">+</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//文件子路径</span>                String ChildFile <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> cnt <span class="token operator">+</span> <span class="token string">"("</span> <span class="token operator">+</span> num<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">")-"</span> <span class="token operator">+</span> Names<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">".jpg"</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//时间间隔</span>                <span class="token keyword">int</span> time <span class="token operator">=</span> <span class="token function">ran</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                File Fileuser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> ChildFile<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//判断图片是否存在</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Fileuser<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//第一种请求 Httpclient请求</span>                    HttpEntity httpEntity1 <span class="token operator">=</span> <span class="token function">request</span><span class="token punctuation">(</span>StrUrl <span class="token operator">+</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//写入文件夹</span>                    InputStream in <span class="token operator">=</span> httpEntity1<span class="token punctuation">.</span><span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    FileUtils<span class="token punctuation">.</span><span class="token function">copyInputStreamToFile</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> Fileuser<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//打印下载信息</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第"</span> <span class="token operator">+</span> num<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span><span class="token string">"页"</span><span class="token operator">+</span>i<span class="token operator">+</span><span class="token string">"-"</span><span class="token operator">+</span>cnt<span class="token operator">+</span><span class="token string">"下载成功，总计有"</span> <span class="token operator">+</span>num<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"页,下次时间间隔是"</span> <span class="token operator">+</span> time <span class="token operator">+</span> <span class="token string">"s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">sleep</span><span class="token punctuation">(</span>time <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第"</span> <span class="token operator">+</span> num<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"页"</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> cnt <span class="token operator">+</span> <span class="token string">"张图片已存在"</span><span class="token comment" spellcheck="true">/*+",本次时间间隔是"+(time*1000)*/</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                cnt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"下载完成!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>测试结果</li></ul><p><img src="https://remmeiko.gitee.io/img-bed/crawler/image-20210429004258127.png" alt="image-20210429004258127"></p><ul><li>附：jar文件我就不公布了，代码差不多已经全部放出来了。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>另外推荐几个壁纸网站</li></ul><blockquote><p>别问，问就是没爬过，只是简单测试过，</p></blockquote><ul><li><p><a href="https://www.quanjing.com/">全景壁纸</a></p></li><li><p><a href="https://wallhaven.cc/">我最常逛的壁纸网站</a></p></li><li><p>知乎</p><ul><li>知乎的话，要复杂一点，但是也更好玩一点</li><li>需要携带cookies，同时直接使用网址是无法拿到图片的，必须去js文件里面结合网页源代码然后进行处理才能拿到图片网址</li><li>好玩的点就在于知乎的每一篇回答的网址都只有一串数字不同，因此写完一个爬虫后，可以弄出来一个模板，当需要访问哪篇回答里的图片时只需要将那串数字输入即可</li></ul></li></ul><blockquote><p>代码不发出来了，和上面整体思路是一样的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> java </tag>
            
            <tag> 贪玩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之查找算法</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%9F%A5%E6%89%BE/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><hr><blockquote><p>写在前面：这些内容是以考研的角度去学习和理解的，很多考试中需要用到的内容在实际应用中可能用不上，比如其中的计算问题，但是如果掌握这些东西会帮你更好的理解这些内容。</p></blockquote><blockquote><ul><li>这篇关于查找的博客也只是用来记录以便于后续复习的，所以很多地方只是浅谈，并没有代码的实现</li><li>如果有缘发现这篇文章想要深入了解或者因为作者表达能力差而看不懂以及有错的地方，欢迎留言指出来，我会尽快去完善的，期待有缘人</li><li>内容多和杂，如果有机会我进一步进行梳理，将其重新梳理一片文章(会更注重于代码)</li><li>本来只是想简单写一下的，但是不小心就get不到重点了</li><li>本来打算等逐步完善和优化后再发出来的，但那样继续往前总感觉有所顾及，所以就先给这几天查找的复习暂时告一段落吧。</li></ul></blockquote><hr><h1 id="导学"><a href="#导学" class="headerlink" title="导学"></a>导学</h1><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210410091941738.png" alt="概览"></p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411105134631.png" alt="总体"></p><h1 id="一-概念"><a href="#一-概念" class="headerlink" title="(一)概念"></a>(一)概念</h1><ul><li>查找：在数据集合中查找特定元素的过程</li><li>查找表(查找结构)：同一类型数据元素构成的集合<ul><li>静态查找表:只涉及查找，不存在修改<ul><li>适用：顺序查找，折半查找，散列查找等</li></ul></li><li>动态查找表:动态插入和删除，对查找表进行修改<ul><li>适用：二叉排序树，散列查找等</li></ul></li></ul></li></ul><blockquote><p>所有数据结构都可以看作是查找表，对于折半查找和顺序查找这些都属于查找算法</p></blockquote><ul><li>关键字：数据元素中唯一标识该元素的某数据项的值<ul><li>主关键字：此关键字能唯一表示一个数据元素</li><li>次关键字：此关键字用以识别若干记录(一对多)</li></ul></li></ul><blockquote><p>说明：在查找表中每个数据元素就相当于一条记录，包含有不同的数据项，例如拿学生为例，一个学生作为数据元素，那么学号，身高，姓名就是这个元素中的数据项，每个学生都有特定的学号，因此学号可以作为关键字。(当然如果数据项包含身份证号，你用身份证号走位关键字也可以)</p></blockquote><h4 id="0x01平均查找长度-重点"><a href="#0x01平均查找长度-重点" class="headerlink" title="0x01平均查找长度(重点)"></a>0x01平均查找长度(重点)</h4><ul><li><strong>注意</strong>：作为查找算法效率衡量的主要指标，那么查找算法的性能分析肯定是重点分析平均查找长度的，因此必须熟练掌握。</li></ul><blockquote><p>提一嘴，算法效率的度量前面学过时间和空间复杂度，但是算法效率的度量不是只取决于时间和空间复杂度，针对不同的算法还可能会有其他一些辅助度量，如查找算法中的平均查找长度。(不过需要注意后面学排序算法时，其稳定性并不是用来衡量算法的优劣的，只是用来描述算法性质的)，下面开始说明平均查找长度</p></blockquote><ul><li>平均查找长度：所有查找过程中进行关键字比较次数的平均值<ul><li>一次查找长度是指需要比较的关键字次数</li><li>成功平均查找长度：所有元素查找成功的情况</li><li>失败平均查找长度：所有元素查找失败的情况</li></ul></li><li>数学公式定义：</li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411222237211.png" alt="image-20210411222237211"></p><blockquote><p>没有特殊说明的情况下，默认每个数据元素的查找概率是相等的，记住就是每个元素查找时比较的次数乘以概率然后加起来</p></blockquote><p>举个例子：</p><table><thead><tr><th>下标</th><th>0</th><th>1</th><th>2</th></tr></thead><tbody><tr><td>查找集中的值</td><td>4</td><td>3</td><td>5</td></tr></tbody></table><p>每个元素的查找概率是1/3,而查找成功时对应的比较次数依次是1，2，3，因此ASL=2（这是成功平均查找长度）</p><p>查找失败时对应的比较次数是4，4，4因此ASL=4</p><ul><li>对于不同的概率计算方法是一样的</li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210410095936434.png"></p><blockquote><p>(成功)平均查找长度就是1/2*1 + 1/3 *2 + 1/6 * 3 = 5/3</p></blockquote><h1 id="二-查找算法"><a href="#二-查找算法" class="headerlink" title="(二)查找算法"></a>(二)查找算法</h1><ul><li>算法的实现取决于数据结构的选取</li><li>数据结构三要素：逻辑结构，存储结构，数据的运算</li><li>下面的学习是以逻辑结构进行划分的</li></ul><blockquote><p>这里我有个疑惑，就是散列结构属不属于线性结构</p><p>线性结构：集合中数据元素之间只存在一对一的关系</p><p>非线性结构有更细的划分(集合—没关系，树形结构—一对多，图形结构—多对多)</p><p>那么散列结构中数据元素之间存不存在一对一的关系呢？</p></blockquote><h2 id="0x02线性结构"><a href="#0x02线性结构" class="headerlink" title="0x02线性结构"></a>0x02线性结构</h2><h3 id="1-顺序查找-一般线性表"><a href="#1-顺序查找-一般线性表" class="headerlink" title="1.顺序查找(一般线性表)"></a>1.顺序查找(一般线性表)</h3><ul><li>思想：又称线性查找，从前往后或者从后往前依次对比进行查找</li><li>优点：对数据元素存储没有要求，顺序表、链表都可以</li><li>缺点：当n较大时，平均查找长度较大，效率低</li><li>重点注意：对于线性的链表，只能进行顺序查找</li></ul><h4 id="1-实现代码"><a href="#1-实现代码" class="headerlink" title="(1)实现代码"></a>(1)实现代码</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 查找表的结构</span>    Elemtype <span class="token operator">*</span> elem<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 指针是采用动态分配，使用时分配</span>    <span class="token keyword">int</span> TableLen<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 查找表长度</span><span class="token punctuation">}</span>Stable<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">Search_Seq</span><span class="token punctuation">(</span>Stable S<span class="token punctuation">,</span>Elemtype key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    S<span class="token punctuation">.</span>elem<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 哨兵</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> S<span class="token punctuation">.</span>TableLen<span class="token punctuation">;</span>i <span class="token operator">!=</span> key<span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>代码不难，但是这里要介绍一个“哨兵”的概念，在这份代码中，S.elem[0]就是哨兵，引入“哨兵”可以避免许多不必要的判断语句，并且随着程序规模增大，效率提升也会越大</li><li>“哨兵”需要额外分配一个空间，这里是将数组下标为0的位置留空作为”哨兵</li><li>注意：在查找时，元素若是查找失败是会和“哨兵”进行一次额外比较的，但是有些考题对于哨兵的这一次比较是不算在查找次数之内的，因此查找长度计算会有所不同，看学校</li></ul><h4 id="2-平均查找长度"><a href="#2-平均查找长度" class="headerlink" title="(2)平均查找长度"></a>(2)平均查找长度</h4><ul><li><p>成功平均查找长度(这里与哨兵的比较是计算在内的)：</p><ul><li>第i个数查找成功需要比较n-i+1次，如果是从前往后进行比较第i个数比较的次数就是i</li><li>每一个元素查找成功的概率是1/n，也就是说P为1/n</li><li>平均查找长度为</li></ul></li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411222416064.png"></p><ul><li><p>失败平均查找长度为：</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411222427692.png"></p></li></ul><h4 id="3-有序表的顺序查找"><a href="#3-有序表的顺序查找" class="headerlink" title="(3)有序表的顺序查找"></a>(3)有序表的顺序查找</h4><ul><li><p>思想：略微特殊的线性表，其中的关键字是有序的，在查找失败时就不用继续往下查找了(比如升序序列，发现第4个元素大于查找的元素，那么后续的元素一定是都大于此元素的，就没有继续查找的必要了)，从而降低失败平均查找长度</p></li><li><p>成功平均查找长度和一般线性表一样</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210408104215522.png"></p></li><li><p><strong>有序表的顺序查找和折半查找不一样，有序表的顺序查找一样适用于链表，而折半查找则无法用在链表的查询上</strong></p></li></ul><h3 id="2-折半查找"><a href="#2-折半查找" class="headerlink" title="2.折半查找"></a>2.折半查找</h3><ul><li>又称二分查找</li><li>基本思想：以升序序列为例，将key值与表中间位置进行比较，相等则查找成功，若小于则在表的左边继续查找，大于则在右边继续查找，每次都是与中间位置进行对比</li><li>注意：只适用于有序的顺序表，同时折半查找需要方便的定位查找区域，所以要求线性表必须具有随机存取的特性，因此只适用于顺序存储结构，不适用于链式存储结构，同时要求元素按关键字有序排列</li></ul><h4 id="1-代码实现"><a href="#1-代码实现" class="headerlink" title="(1)代码实现"></a>(1)代码实现</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">BinarySearch</span><span class="token punctuation">(</span>sqLList L<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> L<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> mid<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 取中间位置，向下取整</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-查找过程"><a href="#2-查找过程" class="headerlink" title="(2)查找过程"></a>(2)查找过程</h4><ul><li>设定一个mid值存储中间位置的值，这个中间位置mid的值为low和high的和除以2然后向下或者向上取整</li></ul><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>7</td><td>10</td><td>13</td><td>16</td><td>19</td><td>29</td></tr></tbody></table><p>查找29(这里采用向下取整)</p><p>第一次：low=0指向7，high=5指向29,此时mid=2指向13</p><blockquote><p>13&lt;29,此时范围缩小至[3,5]，(因为13已经比较过了，所以直接从下一个开始)</p></blockquote><p>第二次：low=3指向16，high=5指向29,此时mid=(3+5)/2=4指向19</p><blockquote><p>13&lt;20,此时范围缩小至[5,5]</p></blockquote><p>第三次：low=5指向29，high=5指向29,此时mid=5指向29</p><blockquote><p>相等–&gt;结束</p></blockquote><ul><li><strong>解题注意：</strong>向上取整和向下取整生成的判定树是有区别的<ul><li>向上取整：左子树节点数 &gt;= 右子树节点数</li><li>向下取整：右子树节点数 &gt;= 左子树节点数</li><li>也就是说：<strong>一颗判定树中要么左子树节点数全部大于等于右子树节点数，要么右子树节点数全部大于左子树节点数</strong></li></ul></li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210408113202825.png"></p><h4 id="3-判定树-重点"><a href="#3-判定树-重点" class="headerlink" title="(3)判定树(重点)"></a>(3)判定树(重点)</h4><ul><li>是折半查找过程生成的一棵二叉树，准确讲是用来折半查找过程的一种描述</li><li><strong>判定树是一颗平衡二叉树同时也是一颗二叉排序树</strong></li></ul><blockquote><p>注意：判定树描述的是折半查找过程中所有节点的查找过程，而折半查找中关键字比较序列指的是这个二叉排序树上的一条路径而已</p></blockquote><p>​    看下面题目：</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210408111558332.png"></p><h4 id="4-判定树说明"><a href="#4-判定树说明" class="headerlink" title="(4)判定树说明"></a>(4)判定树说明</h4><p>例子：7    10    13    16    19    29    32    33    37    41    43</p><p>对应的判定树：</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210408111831739.png"></p><p>说明：</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210408111949050.png"></p><ul><li>叶节点(方形节点)代表查找不成功的情况，但是注意：其方形节点是虚构的，它不计入比较的次数之中</li></ul><blockquote><p>计算ASL时，查找失败节点不适合放行节点，而是方形节点上层的圆形节点</p></blockquote><ul><li>有序序列有n个元素—&gt;判定树有n个非叶节点和n+1个方形的叶节点</li><li>折半查找关键字的比较次数是和其关键字在判定树中的层数有关的，关键字在判定树的第i层，那么查找成功的比较次数就是i</li></ul><h4 id="5-构建判定树-要会"><a href="#5-构建判定树-要会" class="headerlink" title="(5)构建判定树(要会)"></a>(5)构建判定树(要会)</h4><ul><li><p>构建过程个人感觉就像告诉你先序遍历和中序遍历然后让你确定二叉树</p><blockquote><p>不同的是这里每次需要的根节点不是通过先序遍历告诉你，而是通过low+high然后向下取整计算得到</p><p>扩展：什么样的情况下能确定一颗二叉树呢？</p><p>答案：知道先序遍历和中序遍历，或知道后序遍历和中序遍历，或知道层序遍历和中序遍历</p></blockquote></li></ul><p>(动图).ing—&gt;尽快补上</p><h4 id="6-平均查找长度-重点"><a href="#6-平均查找长度-重点" class="headerlink" title="(6)平均查找长度(重点)"></a>(6)平均查找长度(重点)</h4><p>平均查找长度公式：</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210408112806958.png"></p><ul><li>失败查找长度也是根据此公式进行计算，不同的是在判定树上的高度和节点而已</li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210408113505668.png"></p><ul><li>而一般在计算时采用的公式是 </li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411222539730.png"></p><blockquote><p>此公式也是计算判定树树高的公式，关于这个，我的理解是：</p><p>使用第一个求和公式能够准确的计算平均查找长度，而这个一般计算公式求得的结果是比实际查找长度要大的，因为向上取整了，比如本来平均查找长度是5.00023，但是在题目中需要的是整数，因此向上取整就成了6,根据题目来</p></blockquote><p>看个题目，这个题目虽然属于分块查找的，但是主要运算的是折半查找</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210408122637097.png"></p><h4 id="7-关于折半查找题目"><a href="#7-关于折半查找题目" class="headerlink" title="(7)关于折半查找题目"></a>(7)关于折半查找题目</h4><ul><li><p>很多就是给你一个长度已知的顺序表，然后让你求关键字比较次数或平均查找长度</p></li><li><p>解题最重要的思路就是构建判定树，不一定要全部画出来，但是给你一个元素个数要直到判定树的高度</p><hr></li><li><p>这个题考的是判定树高度公式<img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210410102225957.png"></p></li></ul><blockquote><p>选A,记住即可</p></blockquote><ul><li>求关键字比较次数的最值</li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210410100900235.png"></p><blockquote><p>思路：对于折半查找，关键字、节点数目什么的，第一反应就应该是构建判定树（不要真傻傻的画出来）关键字折半查找的比较次数是和判定树高度相关的的</p><p>求解：顺序表长度16，判定树高度是5，所以关键字最多的比较次数就等于树高5</p></blockquote><ul><li>求平均查找长度</li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411084658843.png"></p><blockquote><p>思路：这种题目就需要画出判定树然后进行计算了，</p><p>取有序表元素为0 1 2 3 4 5 6 7 8 9 10 11 </p><p>画出来是这个样子</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411102345123.png"></p><p>查找成功平均查找长度(圆形节点)：判定树的每一层节点数*节点所在高度之和然后除以总个数</p><p>(1* 1 + 2 * 2 + 4 * 3 + 5 * 4)/12=37/12</p><p>查找失败平均查找长度(方型也就是叶子节点)：判定树的每一层节点数*(节点所在高度-1)之和然后除以叶子共个数</p><p>(3 * 3 + 10 * 4)/13 = 49/13</p><p><strong>查找失败平均查找长度中与节点相乘的并不是节点所在高度，而是所在高度-1是因为方形节点在实际上是不存在的，当我们找到方形节点上一层的圆形节点时就已经知道是否查找失败了</strong></p></blockquote><ul><li>判定树</li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411084725219.png"></p><blockquote><p>思路：可能，前面知识点讲过，一棵折半查找判定树所有左子树要么全部大于等于右子树节点数，要么全部小于等于。因此选A</p><p>BCD中都同时存在左子树大于右子树节点数，右子树大于左子树节点数的子树</p><p>以D为例，根节点左子树有4个节点，右子树有5个节点，右子树大于左子树</p><p>而根节点的左子树那个节点的左子树有2个节点，右子树有1个节点，左子树大于右子树</p><p>因此不可能成为折半查找判定树</p></blockquote><ul><li>分块查找最值问题(分块问题不多，就与折半查找放到一起了)</li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411084825962.png"></p><blockquote><p>思路：最好情况就是分块最理想，每个块中有根号n个元素，同时元素之间都是有序的，索引与块内都可以使用折半查找</p><p>求解：</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411222616704.png"></p></blockquote><ul><li>折半查找中关键字比较序列</li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411084922248.png"></p><blockquote><p>思路:这个题其实问的就是下面选项中那些关键字的序列不能构成二叉排序树的一条查找路径</p></blockquote><h3 id="3-分块查找"><a href="#3-分块查找" class="headerlink" title="3.分块查找"></a>3.分块查找</h3><ul><li><p>概念：又称索引顺序查找</p></li><li><p>特点：既有动态结构又便于快速查找，吸取了顺序查找和折半查找的优点</p></li><li><p>基本思想：将查找表分为若干子块，块内元素可以无序，但块之间必须是有序的(也就是说前一块中的最大关键字必须小于后一块中的最小关键字)，然后就是索引表，索引表中存放的是每个块之中最大的关键字和第一个元素的位置。<strong>索引表中的关键字是有序的</strong></p></li><li><p>算法描述：先索引查找，然后在在块中查找。索引查找采用折半查找，块中查找则可以根据情况采用折半查找或者顺序查找</p></li></ul><h4 id="平均查找长度"><a href="#平均查找长度" class="headerlink" title="平均查找长度"></a>平均查找长度</h4><ul><li>分块查找平均长度一般求的是成功平均查找长度</li><li>由于块内查找和索引查找可以采用顺序查找或者折半查找，因此，平均查找长度计算有所不同，但整体思路是一样的，就是将折半查找和顺序查找的平均查找长度进行组合，公式：</li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411222650643.png"></p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210408123130555.png"></p><p><strong>注意：对n个记录的索引顺序表进行分块，最理想的块长是</strong><br>$$<br>\sqrt{n}<br>$$<br><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210408131707460.png"></p><ul><li>分块查找因为不同的查找组合会出现不同的平均查找长度，因此就有最理想，最好情况和最坏情况，看例题</li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210410102950289.png"></p><h2 id="0x03树形结构"><a href="#0x03树形结构" class="headerlink" title="0x03树形结构"></a>0x03树形结构</h2><h3 id="1-二叉排序树-BST"><a href="#1-二叉排序树-BST" class="headerlink" title="1.二叉排序树(BST)"></a>1.二叉排序树(BST)</h3><ul><li><p>也称二叉查找树</p></li><li><p>是一种动态树表，特点是树的结构通常不是一次生成的，而是在查找过程中，当树中不存在关键字等于给定值的节点时进行插入。</p></li><li><p>性质：</p><ul><li>左子树非空则左子树关键字值均不大于(不小于)右子树</li><li>右子树非空则右子树关键字值均不小于(不大于)左子树</li><li>左右子树又各是一颗二叉排序树</li></ul><blockquote><p>很多时候二叉排序树默认是左子树值小于右子树的值，但若有特殊说明则右子树小于左子树也是排序二叉树</p></blockquote></li><li><p>如果对二叉排序树进行<strong>中序遍历</strong>就可以得到一个递增(递减)的有序序列</p></li><li><p>存储结构</p></li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> BTNode <span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 节点存储的数据，这里代表关键字</span>    <span class="token keyword">struct</span> BTNode <span class="token operator">*</span>lchild<span class="token punctuation">;</span>    <span class="token keyword">struct</span> BTNode <span class="token operator">*</span>rchild<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="1-二叉排序树的查找"><a href="#1-二叉排序树的查找" class="headerlink" title="(1)二叉排序树的查找"></a>(1)二叉排序树的查找</h4><ul><li><p>基本思想：(默认二叉排序树)并不复杂，从根节点开始进行比较，相等即返回，key值小于根节点关键字，进入左子树，反之进入右子树</p></li><li><p>递归算法</p></li></ul><pre class=" language-c"><code class="language-c">BTNode <span class="token operator">*</span><span class="token function">BSTSearch</span><span class="token punctuation">(</span>BTNode<span class="token operator">*</span> bt<span class="token punctuation">,</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>bt <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>bt<span class="token operator">-></span>data <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> bt<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>bt<span class="token operator">-></span>data <span class="token operator">></span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">BSTSearch</span><span class="token punctuation">(</span>bt<span class="token operator">-></span>lchild<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">BSTSearch</span><span class="token punctuation">(</span>bt<span class="token operator">-></span>rchild<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>非递归算法</li></ul><pre class=" language-c"><code class="language-c">BSTNode <span class="token operator">*</span><span class="token function">BST_Search</span><span class="token punctuation">(</span>BiNode T<span class="token punctuation">,</span>ElemType key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>T <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> T<span class="token operator">-></span>data <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">-></span>data <span class="token operator">></span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>            T <span class="token operator">=</span> T<span class="token operator">-></span>lchild<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span>            T <span class="token operator">=</span> T<span class="token operator">-></span>rchild<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> T<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>二叉排序树的查找并不难，难点和重点在于经过二叉排序树扩展过来的二叉平衡树等</p></blockquote><h4 id="2-二叉排序树的插入"><a href="#2-二叉排序树的插入" class="headerlink" title="(2)二叉排序树的插入"></a>(2)二叉排序树的插入</h4><ul><li>插入思路：<ul><li>二叉树为空，直接插入节点</li><li>二叉树非空，则进行查找，插入的前提是查找，找到属于该节点的空位置，然后插入</li></ul></li><li><strong>二叉树插入的关键字一定是存储在新创建的叶子上</strong>、</li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">BSTInsert</span><span class="token punctuation">(</span>BTNode <span class="token operator">*</span>bt<span class="token punctuation">,</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>bt <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 这里也是先找到空节点，然后进行插入</span>        bt <span class="token operator">=</span> <span class="token punctuation">(</span>BTNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 因为非空所以先开辟空间</span>        bt<span class="token operator">-></span>lchild<span class="token operator">=</span>bt<span class="token operator">-></span>rchild<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>        bt<span class="token operator">-></span>data <span class="token operator">=</span> key<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">==</span> bt<span class="token operator">-></span>data<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//关键字已存在树中，插入失败</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">&lt;</span> bt<span class="token operator">-></span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">BSTInsert</span><span class="token punctuation">(</span>bt<span class="token operator">-></span>lchild<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span>             <span class="token keyword">return</span> <span class="token function">BSTInsert</span><span class="token punctuation">(</span>bt<span class="token operator">-></span>rchild<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="3-二叉排序树的构造"><a href="#3-二叉排序树的构造" class="headerlink" title="(3)二叉排序树的构造"></a>(3)二叉排序树的构造</h4><ul><li>二叉排序树的构造就是将关键字逐个插入到一颗空树中</li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">CreateBST</span><span class="token punctuation">(</span>BSTNode <span class="token operator">*</span>bt<span class="token punctuation">,</span><span class="token keyword">int</span> key<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    bt <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 一颗空树或者将树清空</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">BSTInsert</span><span class="token punctuation">(</span>bt<span class="token punctuation">,</span>key<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="4-二叉排序树的删除-略微复杂一点"><a href="#4-二叉排序树的删除-略微复杂一点" class="headerlink" title="(4)二叉排序树的删除(略微复杂一点)"></a>(4)二叉排序树的删除(略微复杂一点)</h4><ul><li><p>二叉排序树的节点删除要稍微复杂一点，因为需要    保证在删除节点后的树仍让是一颗二叉排序树</p><p> 假设删除的是p节点，f节点为其双亲</p></li></ul><ol><li><p>p节点为叶子节点，可以直接删除，删除后不会破坏二叉排序树的特性</p></li><li><p>p节点只有右子树或者左子树，此时将p删除然后用p的子树代替p即可</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210408211415493.png"></p></li><li><p>若p节点既有右子树又有左子树，此时令p的直接后继(或直接前驱)替代p,然后将直接后继(或直接前驱)删除即可。<strong>重点在下面</strong></p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210408211350501.png"></p><blockquote><p>什么？你说我怎么知道哪一个是直接后继或者直接前驱？</p><p>来，首先沿着p节点的右子树的根节点的左指针一直往左走，直到来到最左边的那个节点就是直接后继了，直接前驱就是沿着p节点的左子树的右指针一直往右走，直到来到最右边的那个节点就是直接前驱了，<strong>别看我放在这里，这是重点(敲黑板)</strong></p></blockquote></li></ol><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210408211123378.png"></p><h4 id="5-平均查找长度"><a href="#5-平均查找长度" class="headerlink" title="(5)平均查找长度"></a>(5)平均查找长度</h4><blockquote><p>看到这个你想到了什么？                   ———-对对对，就是那个，那个折半查找的判定树</p></blockquote><ul><li><p>需要说明的是二叉排序树和判定树还是有很大区别的，如果此时二叉排序树刚好是一棵二叉平衡树，那么此时平均查找长度和折半查找的判定树是一样的</p></li><li><p>关于不同：二分查找的判定树是唯一的，而二叉排序树是不唯一的，相同关键字因插入顺序可能生成不同的二叉排序树</p><blockquote><p>要问为什么的话？</p><p>因为判定树是根据二分查找生成的，而二分查找的查找集是有序的，要么升序要么降序，然后从中间开始生成，因此生成顺序是唯一的，而对于一个相同元素的集合，二叉排序树的插入顺序可以是随意的，因此生成的二叉树也是不唯一的</p></blockquote></li><li><p>当二叉排序树的平衡因子大于1时，平均查找长度就不一样了，极端情况下，二叉排序树的输入序列是有序的，此时是一颗倾斜的单枝树，平均查找长度就和顺序查找一样了，性能显著变坏(就像下图右边一样)</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210408212256495.png"></p><blockquote><p>所以后面才出现了平衡二叉树，平衡二叉树里不会出现这种极端情况，因为其左右子树的高度差是被限制了的。(当人们发现二叉排序树越极端，效率越低时，就在想能不能通过控制二叉排序树的高度来保证二叉排序树的效率，因此平衡二叉树就出现了)</p></blockquote><p>极端情况相关题目：</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210410105249535.png"></p></li></ul><h4 id="6-二叉排序树相关题目"><a href="#6-二叉排序树相关题目" class="headerlink" title="(6)二叉排序树相关题目"></a>(6)二叉排序树相关题目</h4><ul><li>查找路径(序列)问题</li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210410105536223.png"></p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210410105520548.png"></p><ul><li>插入删除相关题目</li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210410132800780.png"></p><h3 id="2-平衡二叉树"><a href="#2-平衡二叉树" class="headerlink" title="2.平衡二叉树"></a>2.平衡二叉树</h3><h4 id="1-知识点"><a href="#1-知识点" class="headerlink" title="(1)知识点"></a>(1)知识点</h4><ul><li><p>已知平衡二叉树高度求最少节点==已知节点数求最大深度(高度)—&gt;用平衡二叉树递推公式求解</p></li><li><p>以最少节点数构造平衡二叉树的递推公式：(这个公式在解题中很重要)—-&gt;<br>$$<br>N_h=N_{h-1}+N_{h-2}+1\ 如N_0=0，N_1=1;N_2=N_0+N_1+1=2 \其中N_2=2代表构造高度为2的平衡二叉树最少需要2个节点<br>$$</p></li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210410104859589.png"></p><ul><li><p>所有非叶节点的平衡因子均为1,即平衡二叉树满足平衡的最少节点的情况</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210410110112713.png"></p></li></ul><blockquote><p>答案解释在平衡二叉树相关题目模块中</p></blockquote><h4 id="2-概念"><a href="#2-概念" class="headerlink" title="(2)概念"></a>(2)概念</h4><blockquote><p>好了，讲完了二叉排序树，接下来开始平衡二叉树(AVL树)，还记得平均查找长度的英文缩写吗？不记得就上去看(哼~)</p></blockquote><ul><li><p>又称AVL树，(也可简称为平衡树)，是一种特殊的二叉排序树，因此它具有二叉排序树的性质，同时其左右子树都是平衡二叉树</p><blockquote><p>二叉平衡树是排序二叉树的改进</p></blockquote></li><li><p><strong>定义;所有树的左右子树高度之差不超过1</strong>，也就是平衡因子不大于1(只能为-1，0，1)</p><blockquote><p>平衡因子：左子树和右子树的高度之差</p><p>下图中每个节点中的数据就是该树(以该节点为根)的平衡因子</p></blockquote></li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210408213657426.png"></p><h4 id="3-平衡二叉树的插入"><a href="#3-平衡二叉树的插入" class="headerlink" title="(3)平衡二叉树的插入"></a>(3)平衡二叉树的插入</h4><blockquote><p>这个就比较复杂了，复杂的地方在于如果因为插入节点导致树不再平衡就需要进行调整</p><p>那么，如何保证平衡呢？</p></blockquote><ul><li><p>基本思路：当删除或插入导致平衡树的平衡被打破，首先找到插入路径上离插入节点最近的平衡因子大于1的节点p，再对以p节点为根的树进行调整，使之重新达到平衡。调整规律分为(LL,RR,LR,RL)四种情况：</p><blockquote><p>下面的调整描述是王道书上的，如果不好理解建议看一下天勤的描述，较之王道要更通俗一点，这里就不贴出来了</p></blockquote><ol><li><p>LL平衡旋转(右单旋转)</p><p>由于在结点A的左孩子(L)的左子树(L)上插入了新结点，导致<br>A平衡因子由1增至2，以A为根的子树失去平衡，因此需要一次向右旋转操作。</p><p>具体操作过程是将A的左孩子B向右上旋转代替A成为根结点,将A结点向右下旋转成为B的右子树的根结点，而B的原右子树则作为A结点的左子树。<br><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210408215900617.png"></p></li><li><p>RR平衡旋转（左单旋转)</p><p>由于在结点A的右孩子(R）的右子树(R）上插入了新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要一次向左的旋转操作。</p><p>具体操作过程是：将A的右孩子B向左上旋转代替A成为根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树则作为A结点的右子树，如图5.29所示。</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210408220134381.png"></p></li><li><p>LR平衡旋转（先左后右双旋转)</p><p>由于在A的左孩子(L)的右子树(R)上插入新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。</p><p>具体操作过程：先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置，然后再把该C结点向右上旋转提升到A结点的位置，如图5.30所示。</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210408220225724.png"></p></li><li><p>RL平衡旋转（先右后左双旋转)</p><p>由于在A的右孩子(R)的左子树(L)上插入新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。</p><p>具体操作过程：先将A结点的右孩子B的左子树的根结点C向右上旋转提升到B结点的位置，然后再把该C结点向左上旋转提升到A结点的位置，如图5.31所示。</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210408220358727.png"></p></li></ol></li><li><p>在RL和LR平衡旋转中，新节点究竟是插入第二次子树后的左子树还是右子树不影响旋转过程。</p></li><li><p>这里说一下，平衡二叉树的构建和二叉排序树一样就是不断的将节点插入一棵空树，通过调整不断维持其平衡。</p></li><li><p>调整方式的命名：LL，RR，LR，RL并不是对调整过程的描述，而是对不平状态的描述，比如LL是在左子树(L)的左子树(L)上插入节点导致不平衡(调整就是向着反方向调整，因此是右单旋转，向右)，LR是指在其左子树(L)的右子树(R)上插入节点导致不平衡，调整因此是先向左后向右进行两次旋转，RR和RL同理。</p></li></ul><h4 id="4-平均查找长度"><a href="#4-平均查找长度" class="headerlink" title="(4)平均查找长度"></a>(4)平均查找长度</h4><ul><li>和折半查找生成的判定树的平均查找长度是相同的</li></ul><h4 id="5-平衡二叉树相关题目"><a href="#5-平衡二叉树相关题目" class="headerlink" title="(5)平衡二叉树相关题目"></a>(5)平衡二叉树相关题目</h4><ul><li>给定节点求深度最值</li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210410133310109.png"></p><blockquote><p>思路：已知节点求最大深度—&gt;递推公式<br>$$<br>N_{0}=0 \qquad N_1=1  \qquad N_2=N_0+N_1+1=2<br>\N_3=N_2+N_1=4  \qquad N_4=N_3+N_2+1=7<br>\N_5=N_4+N_3+1=12 \qquad N_6=N_5+N_4+1=20<br>$$<br>从递推公式可以看到20是大于13小于21,因此最大深度为6</p></blockquote><ul><li>给定高度求节点最值</li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210410133335918.png"></p><blockquote><p>思路：已知高度求最少节点</p><p>根据上面的公式：5层需要至少12个节点</p></blockquote><ul><li>节点总数问题</li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210410133413041.png"></p><blockquote><p>思路：重点是非叶子节点的平衡因子均为1代表此时平衡二叉树拥有最少的节点，题目就变成了已知高度求最少节点</p><p>根据上面的公式：6层知道需要20个节点</p></blockquote><ul><li>二叉树的构建问题</li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210410133636308.png"></p><blockquote><p>思路：此题考查的是平衡二叉树的构建，本质是考平衡二叉树插入时的平衡调整</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411164225707.png"></p></blockquote><ul><li>综合选项</li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210410133720264.png"></p><blockquote><p>树中最大元素一定无左子树，但可能有右子树，不一定是叶子节点</p></blockquote><ul><li>对插入的理解</li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411090156951.png"></p><blockquote><p>答案：A</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411164950927.png"></p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411165006000.png"></p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411165013020.png"></p><blockquote><p>注意最后一种平衡调整(这里是LR平衡旋转)，先以1为根节点进行左旋，然后以3为节点进行右旋</p></blockquote></blockquote><h3 id="3-B树"><a href="#3-B树" class="headerlink" title="3.B树"></a>3.B树</h3><ul><li><p>B树(B-树)，是一种多路平衡查找树，也是由二叉树变换而来的</p></li><li><p>记住：B树不支持顺序查找(B+树是支持的)</p></li><li><p>B树中所有结点孩子节点个数最大的值称为B树的阶，通常用m表示</p></li><li><p>一棵m阶B树或空树性质：</p><ul><li>每个节点最多有m棵子树，至多含有m-1个关键字</li></ul></li><li><p>若根节点不是终端节点，则至少有两棵子树</p><ul><li>除根节点之外所有非叶节点的子树至少有</li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411222804811.png"></p></li><li><p>除根节点之外所有非叶节点的关键字至少有</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411222817087.png"></p></li></ul><ul><li><p>所有非叶节点结如下：</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210409083638869.png"></p><blockquote><p>说明，K代表的是节点的关键字，且K1&lt;K2&lt;…Kn;P代表的是指向子树根节点的指针，注意P(i-1)指向的子树中的关键字都是小于Ki</p></blockquote></li><li><p>所有叶节点都出现在同一层次上，并且不带信息(实际上这些节点并不存在，指向这些的节点指针为空)，这些也是查找失败到达的位置</p><blockquote><p>虽然实际上并不存在，逻辑上是被当作存在的，因此说叶子节点的时候指的就是这一层节点</p></blockquote></li></ul><ul><li><p>B树属于平衡m叉查找树，其左右子树的高度差不会超过1</p></li><li><p>B树的关键字树比子树数目要小一，就好像一个正方形，关键字是正方形中的内容，而指向子树的指针就是正方形下面的两个端点</p></li><li><p>如果已经规定或者知道了树是m阶B树，那么即使画出来的树的结构图中节点中没有m-1数目的关键字，其在空间分配中也还是占据了m-1个关键字应该占据的空间。</p></li><li><p><strong>放在前面</strong>(理解)</p><p> B树的插入和删除操作后需要进行分裂和合并的目的是使得被修改节点的关键字数目n满足</p></li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411222842065.png"></p><h4 id="1-B树的查找"><a href="#1-B树的查找" class="headerlink" title="(1)B树的查找"></a>(1)B树的查找</h4><ul><li>B树的查找是二叉排序树的扩展，二叉排序树是二路查找，B树是多路</li><li>两个基本操作：查找节点和在节点中查找关键字<ul><li>前一个操作时在磁盘上进行的，后一个操作是在内存中进行的(在找到目标节点后将节点信息读入内存，然后采用顺序查找或折半查找)</li></ul></li><li>基本思路：(此处以升序为例)<ul><li>先从根节点开始，相等即结束，关键字A比key大，就顺着关键字A前面的指针进入子树中，关键字A比key小就进入关键字A后面的指针进入子树中，重复上述过程，直到查找成功或者查找到叶节点时就查找失败(对应指针为空指针)。</li></ul></li></ul><h4 id="2-B树的插入"><a href="#2-B树的插入" class="headerlink" title="(2)B树的插入"></a>(2)B树的插入</h4><ul><li><p>和所有树的构建一样B树的构建也是在一棵空树上不断插入关键字</p></li><li><p>B树比二叉排序树要稍微复杂一点</p></li></ul><blockquote><p>二叉排序树在找到终端节点后插入即可，而B树则需要做额外的处理以使得插入节点后的树满足B树的定义</p></blockquote><ul><li><p>过程：</p><ul><li><p>1–&gt;定位,首先利用上述的查找算法找出最底层的某个非叶节点(注意插入是插入至叶节点)，如果树中已存在该关键字就无法进行插入，不存在的话会找到查找失败的叶节点，则个时候指向查找失败叶节点的上层节点就是我们需要的非叶节点。</p></li><li><p>2–&gt;插入，插入的时候就需要注意情况了，因为在插入一个关键字后可能该节点的关键字数量会超过每个节点允许的最大关键字数目，因此就需要进行调整。所以，两种情况</p><ul><li><p>第一种就是插入一个关键字后节点的关键字数量不大于B树允许的每个节点的最大关键字数量m，直接插入即可(即找到的节点关键字数目小于m-1)</p></li><li><p>第二种就是进行插入后节点的关键字数大于m-1,这个时候就需要进行分裂</p><p>具体过程：</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210409094323635.png"></p><p>​    从中间位置[m/2(向上取整)]将节点关键字分为三部分，分别是中间位置的左边，中间位置的那个数，中间位置的右边，然后将中间位置那个关键字添加到父节点中去，如果此时父节点关键字溢出则将父节点进行分裂。</p></li></ul></li></ul></li></ul><h4 id="3-B树的删除"><a href="#3-B树的删除" class="headerlink" title="(3)B树的删除"></a>(3)B树的删除</h4><ul><li><p>B树的删除重点就是要掌握在删除最底层非叶节点时的不同情况下的合并操作</p></li><li><p>B树的删除要稍微复杂一点，分为几种处理情况</p><ul><li>关键字k位于最底层非叶节点中时，用k的直接前驱(或直接后继)k2替代k,然后删除k2即可</li></ul><blockquote><p>删除最底层非叶节点就是不断的替换然后转换成删除最最曾非叶节点</p><p>直接前驱看删除关键字前一个指针下指向的节点的最大的关键字，后继看关键字后一个指针指向的节点的最小的关键字</p></blockquote><ul><li><strong>重点：</strong>关键字k位于最底层非叶节点，有三种情况</li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210409100817398.png"></p></li></ul><h4 id="4-解题知识点"><a href="#4-解题知识点" class="headerlink" title="(4)解题知识点"></a>(4)解题知识点</h4><ul><li><p>根节点为非终端节点时，最少的字节点数和关键书分别为2和1</p></li><li><p>已知B树中的关键字求最大高度和最小高度</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411222908051.png"></p><blockquote><p>公式推导不难，不用公式做题也不难，但这样就慢了</p><p>这种思想就是求最小高度，就是每棵树都有最大的孩子m</p><p>最大高度就是根节点有两个孩子节点，其他非叶节点都有m/2向上取整孩子节点数</p></blockquote></li><li><p>具有n个关键字的B树有n+1个叶子节点</p><blockquote><p>B树的叶节点对应的查找失败的情况，对n个关键字的查找集合进行查找，失败可能性有n+1种</p><p>理解的话：给你一批有序的数字，然后让你查找k，找不到无非就是三种情况，1落在了那一批数字中间的间隔之中(比如在5、7中找6，失败的原因就是6落在了5和7中间) 2所有数都大于k 3所有数都小于k</p></blockquote></li></ul><h4 id="5-B树相关问题"><a href="#5-B树相关问题" class="headerlink" title="(5)B树相关问题"></a>(5)B树相关问题</h4><ul><li>关于的B树和B+树，选择题一般考察的就是对B树概念的理解以及节点或者关键字的最值问题</li></ul><blockquote><p>其实关于树最多的计算问题就是知道树的深度求最多或者最少的节点数，知道节点数求树的最大深度或者最小深度</p></blockquote><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411090439362.png"></p><blockquote><p>知识点中有，答案n+1</p></blockquote><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411090447090.png"></p><blockquote><p>思路：给定高度求节点的最值，考的就是对于B树的特性，哪些节点至少和至多拥有的子树数目和关键字的数目</p><p>8—&gt;至少：根节点含有两个子节点，其他非叶节点都含有3/2向上取整为2个节点，所以是一颗完全二叉树，个数为2的5次方-1=31</p><p>至多：所有非叶节点都含有3个子节点，1+3+9+27+81=121(此处是等比数列)，一般求至多需要用到等比求和公式</p><p>9—&gt;至少：此处不再是节点而是关键字，但也是含有最少节点数，本质是一样的</p><p>至少：根节点含有2个子节点，其他非叶节点含有的子节点数为5/2向上取整-1为2，但此处高度只有2，都不需要考虑那么多</p><p>直接算，第一层一个节点，第二层2个节点，2*2+1=5，注意：根节点的关键字数可以为1</p></blockquote><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411090745489.png"></p><blockquote><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411222927342.png"></p></blockquote><h3 id="4-B-树"><a href="#4-B-树" class="headerlink" title="4.B+树"></a>4.B+树</h3><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210409101115654.png"></p><ul><li><p>B+树是应数据库所需而生的一种B树的变形树</p></li><li><p>性质：</p><ul><li><p>相同性质</p><ul><li><p>每个分支节点最多有m棵子树(孩子节点)</p></li><li><p>非根叶节点至少有两棵子树</p></li><li><p>除根节点之外所有非叶节点的子树至少有<br>$$<br>\lceil{m/2}\rceil<br>$$</p></li></ul></li><li><p>不同性质：</p><ul><li>节点的子树个数和关键字个数相同</li><li>所有叶节点包含全部关键字及指向其相应记录的指针，叶节点中关键字按有序排列</li><li>所有非叶节点仅起到一个索引的作用，即节点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址，而在B-树中，每个关键字对应一个记录的存储地址。</li></ul></li></ul></li><li><p>通常在B+书中有两个头指针，一个指向根节点，另一个指向关键字最小的叶节点</p></li><li><p>B+树的应用方面从这个题的解析中就能了解</p></li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411091019571.png"></p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411091121576.png"></p><h2 id="0x04散列结构"><a href="#0x04散列结构" class="headerlink" title="0x04散列结构"></a>0x04散列结构</h2><blockquote><p>这一节主要还是将书上的内容内容放上来了，后面还是重点介绍一下题目</p></blockquote><h3 id="1-散列表"><a href="#1-散列表" class="headerlink" title="1.散列表"></a>1.散列表</h3><ul><li>记录在表中的位置和关键字之间存在着确定的关系</li></ul><p><strong>敲黑板：对于考研这一部分要求记住一句话—根据给定的关键字计算出关键字在表中的位置</strong></p><h4 id="1-概念介绍"><a href="#1-概念介绍" class="headerlink" title="(1)概念介绍"></a>(1)概念介绍</h4><ul><li>散列表:根据关键字进行直接访问的数据结构</li></ul><blockquote><p>散列表建立了关键字和存储地址之间的一种映射关系</p></blockquote><ul><li><p>散列函数：把查找表中关键字映射成该关键字对应地址的函数，(这里的地址可以是数组下标、索引或内存地址等)记为<br>$$<br>Hash(key)=Addr<br>$$</p></li><li><p>冲突：散列函数将两个或两个以上的不同关键字映射到同一地址上</p></li><li><p>同义词：发生碰撞(冲突)的不同关键字之间称为同义词</p></li></ul><h4 id="2-散列表的建立"><a href="#2-散列表的建立" class="headerlink" title="(2)散列表的建立"></a>(2)散列表的建立</h4><ul><li>散列表的建立分为两部分，首先是通过散列函数将关键字插入表中，然后如果产生冲突就进行冲突处理，然后将数据插入其中</li></ul><p>下面实际中常用的散列函数：</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210409232511275.png"></p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210409232354941.png"></p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210409232440046.png"></p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210409232541603.png"></p><ul><li>一个好的散列函数应该尽可能的避免产生冲突，但是任何散列函数都会产生冲突，我们所能做的就是尽量降低产生冲突的可能性。</li></ul><p>处理冲突的方法：</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210409233749636.png"></p><ul><li>取定某一增量序列后，对应的处理方法就是确定的，一般有下面四种取法：</li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210409233732924.png"></p><ul><li><p>在采用开放定址的情形下，删除元素只能进行逻辑删除，就是在想要删除的元素位置做一个删除标记,不能进行物理删除。</p><blockquote><p>因为若进行物理删除元素就会截断其他具有相同散列地址元素的查找地址。这样做的副作用就是进行多次删除之后，表面上看散列表很满，实际上有许多位置未利用，因此需要定期维护散列表，将删除标记的元素进行物理删除。</p></blockquote></li><li><p>另一种冲突处理方法：</p></li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210409235202044.png"></p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210409235216596.png" alt="image-20210409235216596"></p><h4 id="3-散列表的查找"><a href="#3-散列表的查找" class="headerlink" title="(3)散列表的查找"></a>(3)散列表的查找</h4><ul><li>散列表的查找与构造基本一致<ul><li>首先根据散列函数查找关键字对应地址是否有记录，若无记录则查找失败，有记录则进行比较，若相等就返回查找成功标志，失败则执行接下来的步骤</li><li>用给定的冲突处理方法计算“下一个散列地址”</li></ul></li><li>散列表的查找效率取决于三个因素：散列函数，冲突处理的方法和装填因子</li><li>散列表的平均查找长度依赖于散列表的装填因子，而不依赖于散列表的长度m和表中记录数n</li></ul><h4 id="4-平均查找长度-1"><a href="#4-平均查找长度-1" class="headerlink" title="(4)平均查找长度"></a>(4)平均查找长度</h4><ul><li><p>平均查找长度会因为散列函数和冲突处理的不同而不同</p><ul><li><p>下面的例子：散列函数–H(key)=key%13 冲突处理–线性探测</p><p>散列表</p></li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411092653392.png"></p><p>​        查找成功关键字比较次数：</p></li></ul><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411092702935.png"></p><blockquote><p>计算方法：首先14%13=1(地址),而1地址存放的刚好就是14，因此比较次数为1</p><p>01%13=1(地址),1地址存放的是14，发生冲突因此采用线性探测(从2位置从前往后查找)继续查找，发现第二个位置是01，因此比较次数为2</p><p>看27%13=1(地址)，1地址存放的非27，开始使用冲突处理继续查找，依次往后找，发现在第四个位置，从前往后依次比较过1，2，3，4，比较次数为4</p><p>依次类推</p></blockquote><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411093230844.png"></p><ul><li>至于查找失败平均查找长度：在后续题目中会进行讲解(emmmm，主要是不晓得咋个说)</li><li>散列查找的平均查找长度的计算有些细节东西是需要注意的，不然很容易出错，具体看最后的题目</li></ul><h4 id="5-其他"><a href="#5-其他" class="headerlink" title="(5)其他"></a>(5)其他</h4><ul><li><p>散列表的装填因子(定义为一个表的装满程度)：</p><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411222945839.png"></p><ul><li>装填因子越大，发生冲突的可能性越大。</li></ul></li></ul><h4 id="6-散列表相关题目"><a href="#6-散列表相关题目" class="headerlink" title="(6)散列表相关题目"></a>(6)散列表相关题目</h4><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411093924301.png"></p><blockquote><p>这里答案是D，但我还是觉得是(K-1)K/2,因为第一个是没有发生冲突的，也就是说进行线性探测的只有K-1个数</p></blockquote><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411093935185.png"></p><blockquote><p>这种题就是比较简单的了，依次将关键字带入散列函数然后看结果为1的个数即可，有4个</p></blockquote><p><img src="https://gitee.com/RemMeiko/img-bed/raw/master/DataStructure/image-20210411093943303.png"></p><blockquote><p>会借着这个题目详细记录一下散列查找的平均查找长度的计算</p><p>首先拿到题目先将散列表画出来，先将所有关键字带入散列函数中得到</p><table><thead><tr><th>关键字</th><th>87</th><th>40</th><th>30</th><th>6</th><th>11</th><th>22</th><th>98</th><th>20</th></tr></thead><tbody><tr><td>散列计算</td><td>3</td><td>5</td><td>2</td><td>6</td><td>4</td><td>1</td><td>0</td><td>6</td></tr></tbody></table><blockquote><p>计算过后发现只有6和20发生了冲突，因为6计算在前，因此对20进行冲突处理得到最终的散列地址</p></blockquote><table><thead><tr><th>散列地址</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>关键字</td><td>98</td><td>22</td><td>30</td><td>87</td><td>11</td><td>40</td><td>6</td><td>20</td><td>NULL</td></tr></tbody></table><p>每个关键字的查找失败长度就是从该关键字的散列地址出发依次往后对比(数),直到找到为空结束</p><p>以关键字98为例，依次往后找，空的散列地址是8，那么一共比较了9次（0~8）</p><p>其他依次类推，散列地址从0<del>8的关键字对应比较的是 (9</del>3次) 然后将所有关键字的查找失败的查找长度相加除以m即可，这里的m是7并不是表长8</p><p>最后结果就是:(9+8+7+6+5+4+3)/7=6</p><p><strong>需要注意的是：</strong>你只能将从0-6地址的关键字的比较次数加起来然后除以7，第7个地址的关键字没有算进来的</p><p>这里很容易出错，很多人都以为是除以表长，其实不然，因为你的散列函数中模长是小于表长的，对于超过模长的关键字比如散列地址为7的关键字散列函数是找不到的</p><ul><li>总结一下：平均查找长度的计算是如果模长小于表长，是只算到模长的</li></ul></blockquote><ul><li>说一下线性探测再散列就是线性探测法</li></ul><blockquote><p>因为王道书上的开放定址法有四种，其中第三个的名字叫再散列法，搞得我以为线性探测再散列法是先线性探测再进行再散列法</p><p>然后发现数据结构教材上开放定址法只写了三个，分别是线性探测再散列，二次探测再散列，伪随机探测再散列，是没有的再散列法的，不过有个再哈希法，这个再哈希法和王道书上的再散列法是不一样的，()这个哈希法采用的是另一种哈希函数)而且不属于开放定址法</p></blockquote><hr><h1 id="一些无关的话题"><a href="#一些无关的话题" class="headerlink" title="一些无关的话题"></a>一些无关的话题</h1><blockquote><p>个人认为最好的学习状态是以实际应用或考试为驱动的学习</p></blockquote><blockquote><p>算法最核心的就是思想，其次就是数据结构，不同的数据结构搭配上算法组成各种各样的程序</p></blockquote><blockquote><p>蓦然回首 ，发现废物竟只剩我自己(心态有点小崩)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构，查找算法，考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云边有个小卖部</title>
      <link href="%E4%BA%91%E8%BE%B9%E6%9C%89%E4%B8%AA%E5%B0%8F%E5%8D%96%E9%83%A8/"/>
      <url>%E4%BA%91%E8%BE%B9%E6%9C%89%E4%B8%AA%E5%B0%8F%E5%8D%96%E9%83%A8/</url>
      
        <content type="html"><![CDATA[<ul><li><p>人生下来就是来遭受苦难的，我们唯一能做的，就是苦中作乐</p></li><li><p>你的焦虑和不安是因为你的实力配不上你的野心</p></li></ul><blockquote><p>前言：此文章收录的是自己的一些感悟和一些随手记录的琐事，如果能当成日记也不错(emmmmm)。有密码拒绝围观。后续所有的这些都会统一收录在这里，我也不是很希望太多这些混杂在学习文章中，而且设置这么多密码也记不住(emmmmm)</p></blockquote><p>写在前面：为什么要花时间写这些东西呢？我有几个原因，一是趁我现在还没有忘记，有一定的时间和精力，想用文字将自己的这些过去记录下来，日后可以回忆，又或许在以后的日子里当我有幸碰见那个愿意和我一起分享一起回忆的人时能有话可说。另一个原因算是把这当作考研期间的一个诉说吧，我是个不会表达的人，很多事情因为怕表达麻烦便会藏在心里，直到堆砌进心中深处慢慢忘记，也算是一种逃避，将这些写出来写进这个树洞会让我轻松一点。(爷不矫情,我说的是实话)</p><p><strong>关于过去，我想记录下我这些紧剩无几的回忆，关于现在，我想让自己感觉到自己是真正的活着，关于未来，我期望我书写的永远是豪言壮志。</strong></p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><ul><li>做一个自己喜欢的关于进击的巨人网站<ul><li>第13个冬季   “战斗吧！战斗吧!”，你一直重复的话语</li><li>三笠.阿克曼  </li></ul></li></ul><p>—-2021.3.16(23:30)</p>]]></content>
      
      
      <categories>
          
          <category> 感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我遇见过的那些句子</title>
      <link href="%E5%85%B3%E4%BA%8E%E6%88%91%E9%81%87%E8%A7%81%E8%BF%87%E7%9A%84%E9%82%A3%E4%BA%9B%E5%8F%A5%E5%AD%90/"/>
      <url>%E5%85%B3%E4%BA%8E%E6%88%91%E9%81%87%E8%A7%81%E8%BF%87%E7%9A%84%E9%82%A3%E4%BA%9B%E5%8F%A5%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>待她再次送我出门的时候，她说：“出去活动活动，去地坛看看书，我说这挺好。”许多年以后我才渐渐听出，母亲这话实际上是自我安慰，是暗自的祷告，是给我的提示，是恳求与嘱咐。</strong></p></blockquote><blockquote><p><strong>瀑布的水逆流而上，蒲公英种子从远处飘回，聚成伞的模样</strong><br><strong>太阳从西边升起，落向东方。</strong><br><strong>子弹退回枪膛，运动员回到起跑线上</strong><br><strong>我交回录取通知书，忘了十年寒窗。</strong><br><strong>厨房里飘来饭菜的香，你把我的卷子签好名字，关掉电视，帮我把书包背上。</strong><br><strong>你还在我身旁</strong></p></blockquote><blockquote><p><strong>—《我与地坛》史铁生</strong></p></blockquote><p>​                                                                </p><h1 id="remmeiko的小屋，不求流芳千古，只求安守一份宁静。"><a href="#remmeiko的小屋，不求流芳千古，只求安守一份宁静。" class="headerlink" title="remmeiko的小屋，不求流芳千古，只求安守一份宁静。"></a>remmeiko的小屋，不求流芳千古，只求安守一份宁静。</h1><h2 id="追逐朝阳的少年终究爱上了夕阳。"><a href="#追逐朝阳的少年终究爱上了夕阳。" class="headerlink" title="追逐朝阳的少年终究爱上了夕阳。"></a>追逐朝阳的少年终究爱上了夕阳。</h2><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
            <tag> 句子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux作业(俄罗斯方块Tetris)</title>
      <link href="Tetris(Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A11)/"/>
      <url>Tetris(Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A11)/</url>
      
        <content type="html"><![CDATA[<h1 id="Tetris-俄罗斯方块小游戏"><a href="#Tetris-俄罗斯方块小游戏" class="headerlink" title="Tetris(俄罗斯方块小游戏)"></a>Tetris(俄罗斯方块小游戏)</h1><ul><li>github地址：<a href="https://github.com/Gregwar/ASCII-Tetris.git">https://github.com/Gregwar/ASCII-Tetris.git</a></li><li>文件：<ul><li>main.c </li><li>tetris.c </li><li>tetris.h</li></ul></li></ul><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="1-terris-h"><a href="#1-terris-h" class="headerlink" title="1.terris.h"></a>1.terris.h</h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">ifndef</span> TETRIS_H</span><span class="token macro property"># <span class="token directive keyword">define</span> TETRIS_H</span><span class="token comment" spellcheck="true">// 定义了一个结构体</span><span class="token keyword">struct</span> tetris<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_cleanup_io</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_signal_quit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_set_ioconfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">,</span><span class="token keyword">int</span> w<span class="token punctuation">,</span><span class="token keyword">int</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_clean</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_print</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_run</span><span class="token punctuation">(</span><span class="token keyword">int</span> width<span class="token punctuation">,</span> <span class="token keyword">int</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_new_block</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_new_block</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_print_block</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_rotate</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_gravity</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_fall</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_check_lines</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">tetris_level</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">//TETRIS_H</span></code></pre><p>这里面定义了一个tetris结构体，其他就是一些函数声明。参数基本上都是tetris结构体指针，关注tetris结构体和tetris_run方法(因为在main函数中被调用)，根据tetris_run调用其他函数的顺序逐渐分析其他函数</p><blockquote><p>C语言程序中，项目一般按功能模块化进行结构化设计，每个功能的相关程序放在一个C程序文档中，称之为一个模块。一个模块通常由两个文件组成，一个是头文件.h文件，包含了C函数声明和宏定义，简单来说就是对模块中的数据结构和函数原型进行描述，另一个则是.c文件，对数据实例或对象定义，以及函数算法具体实现。</p></blockquote><h3 id="2-main-c"><a href="#2-main-c" class="headerlink" title="2.main.c"></a>2.main.c</h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;tetris.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">tetris_run</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>main函数中只调用了tetris_run()方法，参数是两个int整数，看函数声明估计是宽度和长度。</p><h3 id="3-tetris-c"><a href="#3-tetris-c" class="headerlink" title="3.tetris.c"></a>3.tetris.c</h3><ul><li>这里只是简单贴一下tetris结构体</li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> tetris <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 定义了一个二级指针</span>    <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>game<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 宽度</span>    <span class="token keyword">int</span> w<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 高度</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 等级</span>    <span class="token keyword">int</span> level<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 游戏是否结束标志位</span>    <span class="token keyword">int</span> gameover<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 分数</span>    <span class="token keyword">int</span> score<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 定义了一个下坠俄罗斯方块的结构体</span>    <span class="token keyword">struct</span> tetris_block <span class="token punctuation">{</span>        <span class="token keyword">char</span> data<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> w<span class="token punctuation">;</span>        <span class="token keyword">int</span> h<span class="token punctuation">;</span>    <span class="token punctuation">}</span> current<span class="token punctuation">;</span>        <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>关于tetris_block结构体中下坠的俄罗斯方块的结构体相关的结构体数组(用于后面的俄罗斯方块随机下落)</li></ul><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// data[][],w,h</span><span class="token comment" spellcheck="true">// 形状，宽度，长度</span><span class="token keyword">struct</span> tetris_block blocks<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token punctuation">{</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"##"</span><span class="token punctuation">,</span>          <span class="token string">"##"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">" X "</span><span class="token punctuation">,</span>         <span class="token string">"XXX"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"@@@@"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"OO"</span><span class="token punctuation">,</span>         <span class="token string">"O "</span><span class="token punctuation">,</span>         <span class="token string">"O "</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"&amp;&amp;"</span><span class="token punctuation">,</span>         <span class="token string">" &amp;"</span><span class="token punctuation">,</span>         <span class="token string">" &amp;"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"ZZ "</span><span class="token punctuation">,</span>         <span class="token string">" ZZ"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="知识点介绍"><a href="#知识点介绍" class="headerlink" title="知识点介绍"></a>知识点介绍</h2><h3 id="timespec结构体"><a href="#timespec结构体" class="headerlink" title="timespec结构体"></a>timespec结构体</h3><p><code>  struct timespec tm;</code></p><blockquote><p>这是一个系统时钟的结构体数据类型，有两个成员，一个是秒，一个是纳秒，所以最高精确度是纳秒，函数定义：</p></blockquote><blockquote><p>struct timespec {<br>    time_t tv_sec; // seconds<br>    long tv_nsec; // and nanoseconds<br>};</p></blockquote><h3 id="srand-函数"><a href="#srand-函数" class="headerlink" title="srand()函数"></a>srand()函数</h3><p><code> srand(time(NULL));</code></p><blockquote><p>作用：进行重新播种</p></blockquote><blockquote><p>使用&lt;stdlib.h&gt;头文件中的rand函数产生伪随机数，int rand(void)</p></blockquote><blockquote><p>随机数的本质：rand() 函数产生的随机数是伪随机数，是根据一个数值按照某个公式推算出来的，这个数值我们称之为“种子”。种子和随机数之间的关系是一种正态分布，种子在每次启动计算机时是随机的，但是一旦计算机启动以后它就不再变化了；也就是说，每次启动计算机以后，种子就是定值了，所以根据公式推算出来的结果（也就是生成的随机数）就是固定的。</p></blockquote><blockquote><p>通过 srand() 函数来重新“播种”，这样种子就会发生改变。在实际开发中，我们可以用时间作为参数，只要每次播种的时间不同，那么生成的种子就不同，最终的随机数也就不同。使用 &lt;time.h&gt; 头文件中的 time() 函数即可得到当前的时间（精确到秒）。函数声明：</p></blockquote><blockquote><pre class=" language-C"><code class="language-C">void srand (unsigned int seed);</code></pre></blockquote><h3 id="nanosleep-函数"><a href="#nanosleep-函数" class="headerlink" title="nanosleep()函数"></a>nanosleep()函数</h3><p><code>   nanosleep(&amp;tm, NULL);</code></p><blockquote><p>nanosleep函数,暂停某个进程直到规定时间后恢复，参数rqtp是你定义的时间间隔，或者在指定时间间隔内有信号传递到当前线程。由于调用nanosleep是是进程进入TASK_INTERRUPTIBLE,这种状态是会相应信号而进入TASK_RUNNING状态的，这就意味着有可能会没有等到你规定的时间就因为其它信号而唤醒，此时函数返回-1，切还剩余的时间会被记录在rmtp中。函数原型：</p></blockquote><blockquote><p>#include &lt;time.h&gt;<br>int nanosleep(const struct timespec *rqtp, struct timespec *rmtp);</p><p>接受的参数是timespec 结构体数据类型,在前面介绍过</p></blockquote><h3 id="getchar-函数"><a href="#getchar-函数" class="headerlink" title="getchar()函数"></a>getchar()函数</h3><p><code>getchar()</code></p><ul><li>头文件：&lt;stdio.h&gt;</li><li>函数原型：int getchar(void)</li><li>返回值：以无符号 char 强制转换为 int 的形式返回读取的字符，如果到达文件末尾或发生读错误，则返回 EOF</li><li>函数原理：当程序调用getchar时，程序会阻塞，等着用户按键。用户输入的字符被存放在键盘缓冲区中。直到用户按回车为止。当用户键入回车之后，getchar才开始从缓冲区每次读入一个字符。getchar函数的返回值是用户输入的字符的ASCII码，若文件结尾则返回-1(EOF)，且将用户输入的字符回显到屏幕。如用户在按回车之前输入了不止一个字符，其他字符会保留在键盘缓存区中，等待后续getchar调用读取。也就是说，后续的getchar调用不会等待用户按键，而直接读取缓冲区中的字符，直到缓冲区中的字符读完后，才等待用户按键</li></ul><h3 id="malloc-函数"><a href="#malloc-函数" class="headerlink" title="malloc()函数"></a>malloc()函数</h3><ul><li><p>头文件: stdlib</p></li><li><p>函数原型：void *molloc(unsigned int size);</p></li><li><p>参数：无符号整数型unsigned int size，要分配的字节数</p></li><li><p>返回值：成功则返回分配空间的起始地址</p></li><li><p>注意：需要和free配套使用，防止内存泄漏</p></li></ul><blockquote><p>free函数原型: void free(void * ptr)</p></blockquote><h3 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h3><ul><li><p>这个程序中使用了两个坐标系：<strong>笛卡尔坐标系</strong>(整体界面)和<strong>行列式坐标系</strong>(俄罗斯方块)</p></li><li><p>这两个坐标系的区别个人理解就是，笛卡尔坐标系就是我们平常使用的坐标系，x坐标代表的是所在列，y代表的是所在行，</p></li><li><p>行列式刚好相反坐标系，x代表的是所在行，y代表的是坐在列</p></li></ul><blockquote><p>eg:一个3*3的网格，第二行第三个网格使用笛卡尔坐标系表示是(3，2)，采用行列式坐标系表示是(2，3)</p></blockquote><h2 id="程序函数分析"><a href="#程序函数分析" class="headerlink" title="程序函数分析"></a>程序函数分析</h2><h4 id="整体程序流程"><a href="#整体程序流程" class="headerlink" title="整体程序流程"></a>整体程序流程</h4><p><img src="https://remmeiko.gitee.io/img-bed/boke-img/Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/(%E4%BD%9C%E4%B8%9A1)%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="整体流程图"></p><ul><li>下面是整个程序中使用到的部分函数</li></ul><h4 id="tetris-hittest函数"><a href="#tetris-hittest函数" class="headerlink" title="tetris_hittest函数"></a>tetris_hittest函数</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tetris_hittest</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>X<span class="token punctuation">,</span>Y<span class="token punctuation">;</span>    <span class="token keyword">struct</span> tetris_block b<span class="token operator">=</span>t<span class="token operator">-></span>current<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*    双重循环 以俄罗斯方块的宽为第一重循环，俄罗斯方块的高为第二重循环，在分别加上其在整体界面上的x,y坐标，表示将区域限定在了俄罗斯小方块的界面上，并从左至右，从上至下进行遍历，对方块的每个格子进行判定    */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> x<span class="token operator">&lt;</span>b<span class="token punctuation">.</span>w<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> y<span class="token operator">&lt;</span>b<span class="token punctuation">.</span>h<span class="token punctuation">;</span> y<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            X<span class="token operator">=</span>t<span class="token operator">-></span>x<span class="token operator">+</span>x<span class="token punctuation">;</span>            Y<span class="token operator">=</span>t<span class="token operator">-></span>y<span class="token operator">+</span>y<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 方块是否越过左右边界</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>X<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> X<span class="token operator">>=</span>t<span class="token operator">-></span>w<span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 俄罗斯方块是否为空</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token punctuation">.</span>data<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">' '</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 判断俄罗斯方块的底层布局上是否已经有下落方块</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Y<span class="token operator">>=</span>t<span class="token operator">-></span>h<span class="token punctuation">)</span> <span class="token operator">||</span>                         <span class="token punctuation">(</span>X<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> X<span class="token operator">&lt;</span>t<span class="token operator">-></span>w <span class="token operator">&amp;&amp;</span> Y<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> t<span class="token operator">-></span>game<span class="token punctuation">[</span>X<span class="token punctuation">]</span><span class="token punctuation">[</span>Y<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>参数：tetris结构体指针</li><li>返回类型：int(0，1)—0代表正常返回，1代表异常结束返回</li><li>功能：主要是通过判定条件返回1或0，其他函数根据1或0进行功能的设计</li><li>在整个程序中被频繁使用,具体作用需要具体分析</li></ul><h4 id="tetris-print函数"><a href="#tetris-print函数" class="headerlink" title="tetris_print函数"></a>tetris_print函数</h4><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 整个俄罗斯方块程序是一个终端程序，因此是采用间隔打印的方式来实现动态游戏的</span>    <span class="token comment" spellcheck="true">// 意思就是每个一定的时间就会重新打印一次界面</span><span class="token keyword">void</span><span class="token function">tetris_print</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">,</span>y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 打印30次回车空行来将上一次打印的界面给隐藏起来，毕竟一个屏幕也只能显示这么多行</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> x<span class="token operator">&lt;</span><span class="token number">30</span><span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 打印等级和分数</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[LEVEL: %d | SCORE: %d]\n"</span><span class="token punctuation">,</span> t<span class="token operator">-></span>level<span class="token punctuation">,</span> t<span class="token operator">-></span>score<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> x<span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">*</span>t<span class="token operator">-></span>w<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*    重点就在这:因为这里还需要打印在整个界面中间打印俄罗斯方块，将整体界面当作一个棋盘，重点是if语句    使用的是双重for循环来遍历整个棋盘，遍历到的地方当作一个格子    x:棋盘的宽，从左边开始    y:棋盘的高，从上面开始    t->w:棋盘的整个宽度    t->h:棋盘的整个高度    t->x:俄罗斯方块在整个棋盘中的x坐标    t->y:俄罗斯方块在整个棋盘中的y坐标    t->current.w：俄罗斯方块的宽    t->current.h: 俄罗斯方块的高    先从y开始循环，就是从最上面一行开始    */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> y<span class="token operator">&lt;</span>t<span class="token operator">-></span>h<span class="token punctuation">;</span> y<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> x<span class="token operator">&lt;</span>t<span class="token operator">-></span>w<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/*            这里需要理解的是，前面说过这个程序是两个界面，一个是底层的整体界面，就是这个棋盘，另一个就是俄罗斯方块界面，是一个小的重叠在底层界面之上的一个独立界面。            这个循环就是将目标区域缩小在了俄罗斯方块这个小界面上(大于等于俄罗斯方块的x和y坐标，小于其位置加上俄罗斯方块的宽度和高度)，然后将这个小区域中非空的区域继续打印，其他地方即else所表示的地方打印game数组中存放的数据即可，就是打印空或者已经降下的俄罗斯方块。            */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">>=</span>t<span class="token operator">-></span>x <span class="token operator">&amp;&amp;</span> y<span class="token operator">>=</span>t<span class="token operator">-></span>y                     <span class="token operator">&amp;&amp;</span> x<span class="token operator">&lt;</span><span class="token punctuation">(</span>t<span class="token operator">-></span>x<span class="token operator">+</span>t<span class="token operator">-></span>current<span class="token punctuation">.</span>w<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> y<span class="token operator">&lt;</span><span class="token punctuation">(</span>t<span class="token operator">-></span>y<span class="token operator">+</span>t<span class="token operator">-></span>current<span class="token punctuation">.</span>h<span class="token punctuation">)</span>                     <span class="token operator">&amp;&amp;</span> t<span class="token operator">-></span>current<span class="token punctuation">.</span>data<span class="token punctuation">[</span>y<span class="token operator">-</span>t<span class="token operator">-></span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token operator">-</span>t<span class="token operator">-></span>x<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">' '</span><span class="token punctuation">)</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span> t<span class="token operator">-></span>current<span class="token punctuation">.</span>data<span class="token punctuation">[</span>y<span class="token operator">-</span>t<span class="token operator">-></span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token operator">-</span>t<span class="token operator">-></span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span>t<span class="token operator">-></span>game<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> x<span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">*</span>t<span class="token operator">-></span>w<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" 方块横坐标(t->x)：%d\n 方块纵坐标(t->y)：%d\n 方块的宽度(t->current.w)：%d\n 方块的长度(t->current.h)：%d\n"</span><span class="token punctuation">,</span>t<span class="token operator">-></span>x<span class="token punctuation">,</span>t<span class="token operator">-></span>y<span class="token punctuation">,</span>t<span class="token operator">-></span>current<span class="token punctuation">.</span>w<span class="token punctuation">,</span>t<span class="token operator">-></span>current<span class="token punctuation">.</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>参数：tetris结构体指针</li><li>返回类型：void</li><li>功能：打印整个游戏界面</li></ul><blockquote><p>整个程序是使用有两个界面，一个是底层的整体界面，还有一个就是俄罗斯方块的界面，但是计算机只能一行一行打印，因此打印的时候就需要设计一些简单的算法(譬如什么时候打印空格，什么时候打印俄罗斯方块等等)，具体可以看注释</p></blockquote><h4 id="tetris-print-block-函数"><a href="#tetris-print-block-函数" class="headerlink" title="tetris_print_block()函数"></a>tetris_print_block()函数</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tetris_print_block</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>X<span class="token punctuation">,</span>Y<span class="token punctuation">;</span>    <span class="token keyword">struct</span> tetris_block b<span class="token operator">=</span>t<span class="token operator">-></span>current<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*    循环遍历整个俄罗斯方块界面，如果非空则存入game数组中    */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> x<span class="token operator">&lt;</span>b<span class="token punctuation">.</span>w<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> y<span class="token operator">&lt;</span>b<span class="token punctuation">.</span>h<span class="token punctuation">;</span> y<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token punctuation">.</span>data<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">' '</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 存入game数组中</span>                t<span class="token operator">-></span>game<span class="token punctuation">[</span>t<span class="token operator">-></span>x<span class="token operator">+</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>t<span class="token operator">-></span>y<span class="token operator">+</span>y<span class="token punctuation">]</span><span class="token operator">=</span>b<span class="token punctuation">.</span>data<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>参数：tetris结构体指针</li><li>返回类型：void</li><li>功能：将已经下落☞最底层的俄罗斯方块存入game数组(底层接界面)中</li></ul><blockquote><p>这里有一点，就是程序中有一个tetris_gravity函数，用来控制方块下降使用的，除了加速调用过之外，每循环350次也会被调用一次，在这里会根据tetris_hittest()函数的返回结果决定是否调用tetris_hittest函数</p></blockquote><ul><li>在这个调用的时候，如果tetris_hittest()函数返回1则表示已经有方块存在了，说明已经到底了</li></ul><blockquote><p>其实一开始我也很好奇这个是怎样判断下落的下一个位置已经存在方块了。</p></blockquote><h4 id="tetris-gravity-函数"><a href="#tetris-gravity-函数" class="headerlink" title="tetris_gravity()函数"></a>tetris_gravity()函数</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">tetris_gravity</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">,</span>y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 方块的的y坐标加1,表示额外下降一格，从视觉上就如加速一样</span>    t<span class="token operator">-></span>y<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果返回1 表示下一个+1的位置已经有方块了，不能在下降了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tetris_hittest</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// y--将y重新设置回去</span>        t<span class="token operator">-></span>y<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这个方块就此结束，已经触底了，将方块存入至game数组中</span>        <span class="token function">tetris_print_block</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">tetris_new_block</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="白话文瞎说一通-23333"><a href="#白话文瞎说一通-23333" class="headerlink" title="白话文瞎说一通(23333)"></a>白话文瞎说一通(23333)</h4><ul><li>游戏界面 W*H    小俄罗斯方块界面  w *h </li></ul><p>流程：main方法调用tetris_run()函数，tetris_run()函数创建系统时间结构体tm和俄罗斯方块结构体t,tetris_set_ioconfig(),tetris_init()函数进行初始化，利用srand()产生随机数种子用于随机生成俄罗斯方块，接下来tetris_new_block()方法随机生成俄罗斯方块，方块生成位置为中间位置，整个界面的初始点是左上角，方块初始位置(W/2-w/2,0),根据gameover标志位的值判断游戏是否结束，未结束进入while循环，执行nanosleep休眠函数，定义记录变量count,循环一次加1，每50次调用一次tetris_print()函数打印界面，每350次会先后调用tetris_gravity()函数tetris_check_lines()函数来将方块的 位置加1和检查界面中是否有方块已经存满一行了，其中tetris_gravity()函数中有tetris_print_block()函数来将下落的方块存入game数组中，如果有则调用tetris_fall()方法消去，在while循环中同时定义了一个键盘扫描的while循环函数，通过getchar()获取键盘输入，getchar()函数前面有介绍，根据按下的按键执行对应的函数，s和w对应tetris_gravity()和tetris_rotate()函数。a和d则分别对于位置的x进行减加，同时每次调用tetris_hittest()函数进行检查。</p><h2 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h2><p><a href="http://c.biancheng.net/view/2043.html">srand和随机数</a></p><p><a href="https://baike.baidu.com/item/getchar%28%29/6876946?fr=aladdin">getchar函数</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 作业 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="Java%E5%9F%BA%E7%A1%80/"/>
      <url>Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>java中有三种注释：单行注释、多行注释和文档注释</p><ul><li>单行注释 <code>// 这是单行注释</code></li><li>多行注释   <code>/*这是多行注释*/</code></li><li>文档注释(Javadoc)    <code>/**这是文档注释*/</code></li></ul><p>文档注释只能放在类、接口、方法、构造器、成员字段之前，由描述部分和标记部分组成，描述部分和标记部分之间通过空行区分，是专门为javadoc工具自动生成文档而写的注释</p><p>里面含有一些特殊标签(简单列举)：</p><table><thead><tr><th>标签</th><th>描述</th><th>范围</th><th>示例</th></tr></thead><tbody><tr><td>@author</td><td>作者</td><td>文件、类、方法</td><td>@author remmeiko</td></tr><tr><td>@since</td><td>JDK版本</td><td>文件、类</td><td>@since 1.8</td></tr><tr><td>@version</td><td>软件版本号</td><td>文件、类、方法</td><td>@version 1.0.0</td></tr><tr><td>@param</td><td>方法参数</td><td>方法</td><td>@param 参数名称 参数描述</td></tr><tr><td>@return</td><td>方法返回值</td><td>方法</td><td>@return 返回值描述</td></tr></tbody></table><blockquote><p>程序中的文档注释遵守一定的规范，便可以通过Javadoc工具从源代码中抽取这些注释生成API帮助文档，Java帮助文档主要用来说明类、成员变量和方法的功能</p></blockquote><blockquote><p>使用Javadoc工具生成帮助文档：<code>  javadoc -encoding UTF-8 -charset UTF-8 java.java</code></p><p>使用Intellij开发工具:Tools–&gt;Generate JavaDoc–&gt;Other command line arguments输入-encoding UTF-8 -charset UTF-8设置编码格式–&gt;确定</p></blockquote><p><strong>写程序必须养成写注释的习惯，注释是程序的规范之一</strong></p><h2 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>Java语言中，类、接口、变量、常量、函数、语句块等名字统称为Java标识符，说白了就是Java语言中自己命名的名字。</p><p><code>String name = &quot;remmeiKo&quot;</code></p><p>在这个里面name就是标识符</p><h3 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h3><ul><li>标识符可以是字母(a-z,A-Z)，$符号或者下划线(_)或者数字的任何组合，但是<strong>数字不能作为标识符的开头</strong><ul><li>比如2u_d,u_d￥是非法的，u_d,u_d$是合法的标识符</li></ul></li><li>标识符是大小写敏感的</li><li>不能使用关键字作为名字(方法名、变量名等)</li><li>命名应该尽量使用英文并且做到见名知意</li></ul><h3 id="关键字-保留字"><a href="#关键字-保留字" class="headerlink" title="关键字(保留字)"></a>关键字(保留字)</h3><p>Java中具有特殊含义的标识符，不能用来作为方法名、包名等使用</p><p><img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%BA%8C%E7%AF%87/1-%E5%85%B3%E9%94%AE%E5%AD%97.png" alt="关键字"></p><p>在使用过程中会逐渐熟悉</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Java是一种强类型语言，其数据类型有两种，基本类型(primitive type)和引用类型(reference type)，第一次申明变量时必须申明变量类型</p><blockquote><p>强类型语言：强弱类型这个东西比较抽象和复杂，众说纷纭，百度百科说的是强类型指的是程序中表达的任何对象所从属的类型都必须能在编译时刻确定,任何变量在使用时必须指定该变量的类型,不经过强制转换，它永远是这个数据类型，不允许隐式的类型转换。</p><p>按照百度百科通俗理解的是Java应该是弱类型语言。所以我的理解就是倾向于类型转换的是弱类型语言，反之则是强类型语言。像弱类型语言类型转换是很随意的，布尔类型和其他类型也能相互转换。</p></blockquote><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>也被成为内置类型</p><ul><li>整数型<ul><li>byte，占用1个字节，范围：-128-127</li><li>short，占用2个字节，范围：-32768-32767</li><li>int，占用4个字节，范围：-2147483648-2147483647(20亿左右，一般整数使用int就够了)</li><li>long，占用8个字节，范围：-2^31~2^31-1</li></ul></li><li>浮点型<ul><li>float，占用4个字节</li><li>double，占用8个字节</li></ul></li><li>字符类型<ul><li>char，占用2个字节</li></ul></li><li>布尔类型<ul><li>boolean，只有如果虚拟机的实现按照规范来则在数组情况下占用1个字节，单个占用4个字节</li></ul></li></ul><blockquote><p>二进制的前缀是0b</p><p>八进制的前缀是0</p><p>十六进制的前缀是0x</p><p>比如2分别用二进制，八进制，十六进制表示是0b10，002 0x02</p></blockquote><h4 id="布尔类型扩展"><a href="#布尔类型扩展" class="headerlink" title="布尔类型扩展"></a>布尔类型扩展</h4><p><strong>if(flag == true) 和 if(flag)尽量采用后者</strong></p><p>关于布尔类型的大小有几种说法;</p><ul><li>1个bit位</li><li>1个字节</li><li>4个字节</li></ul><p>布尔类型只有true和false两个可能的值，也就是真和假，那么用0和1来表示就可以了，也就是说用一个bit位就足够了，但是计算机处理数据的最小单位是1个字节，（计算机寻址操作以字节为最小单位进行）也就是说实际存储的空间需要一个字节。别急，接着往下看：</p><blockquote><p>在《虚拟机规范》中对于布尔类型有专门的解释：“虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，（因此）每个boolean元素占8位”</p></blockquote><p>也就是说在数组情况下占用1个字节，单个占用4个字节</p><blockquote><p>这里要说一点，世界上制作了Java虚拟机(JVM)的除了Oracle公司还有许多公司，详情可以看<a href="https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines">维基百科JVM比较</a>,意思就是因为虚拟机的不同因此情况也可能需要另作讨论</p></blockquote><p>最后的结论就是：如果虚拟机遵守《虚拟机规范》，在数组情况下布尔类型占用1个字节，单个占用4个字节</p><h4 id="浮点型扩展"><a href="#浮点型扩展" class="headerlink" title="浮点型扩展"></a>浮点型扩展</h4><p>银行家业务，对于精确度高的场景使用大数类型，浮点型会出现舍入误差</p><p>先提一个问题：0.1+0.2=？</p><p>这句话会打印什么:<code>System.out.println(0.1+0.3);</code></p><p><img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%BA%8C%E7%AF%87/2-%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C.png" alt="打印结果"></p><p>打印出来的并不是0.3,为什么会这样？</p><h5 id="浮点数的存储"><a href="#浮点数的存储" class="headerlink" title="浮点数的存储"></a>浮点数的存储</h5><p>IEEE754标准中浮点数表示法是一种科学计数法，组成分为三部分：</p><ul><li><p>符号位(sign),用来区分浮点数的正负，0表示正数，1表示负数</p></li><li><p>指数位(exponent):用来存储指数，范围是0-255,因为指数可能为负数，为此实际指数位存储的是指数减去偏移量(需要转换成二进制)</p></li><li><p>尾数位(fraction)：保存尾数(这个尾数不仅包括小数部分)</p></li></ul><table><thead><tr><th>Type</th><th>符号位</th><th>指数位</th><th>尾数位</th><th>偏移量</th><th>总位数</th></tr></thead><tbody><tr><td>float</td><td>1位</td><td>8位</td><td>23位</td><td>127</td><td>32位</td></tr><tr><td>double</td><td>1位</td><td>11位</td><td>52位</td><td>1023</td><td>64位</td></tr></tbody></table><p><img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%BA%8C%E7%AF%87/3-float%E5%AD%98%E5%82%A8.png"></p><blockquote><p>科学计数法：举例–0.00213 科学计数法为2.13*10^-3  这里5是指数</p><p>浮点数也是一样，采用的是二进制，如采用二进制来表示整数和小数，举例100.10101—-&gt;科学计数法就是1.0010101*2^2</p><p>这里指数就是2,将其加上偏移量转换成二进制便得到了指数位</p><p>科学计数法中小数点后的便是尾数位，需要注意的是浮点型的尾数位数，当超过这个位数后便会直接截断舍去，这也是造成误差的原因。</p></blockquote><h5 id="存储计算"><a href="#存储计算" class="headerlink" title="存储计算"></a>存储计算</h5><p>以2.3这个小数为例，这里采用的是float型，我们计算一下在计算机中是如何以二进制存储的。</p><p>符号位：0    因为是正数</p><p>先将其化为二进制（乘2除整）：10.01001100110011001100110  (这里只取23位)</p><blockquote><p>2 –&gt; 10</p><p>0.3 –&gt; 01001100110011001100110</p></blockquote><p>再将其转换成科学计数：1.0010_0110_0110_0110_0110_011  * 2^1</p><p>我们看到其指数为1，将其加上偏移量127后为128，二进制是1000_0000，因此指数位为1000_0000</p><p>小数位：0010_0110_0110_0110_0110_011</p><p>最后结果：0 1000_0000 0010_0110_0110_0110_0110_011</p><h5 id="误差原因"><a href="#误差原因" class="headerlink" title="误差原因"></a>误差原因</h5><p>当我们把小数转换成二进制的时候，很多时候得到的是一个二进制无限循环小数，但是我们的浮点型对于尾数的位数却是有限的，当超过这个位数后面的数据便会被舍去，float的尾数是23位，double的尾数是52位，double比float精确度要高很多，但也是存在误差的，0.1+0.2!=0.3的前提是使用double型。</p><p><strong>二进制可以精确的表示位数有限并且分母是2的倍数的小数</strong></p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul><li>对于精确度比较高的项目或者场景就不能使用浮点型，浮点型会出现舍入误差例如银行业务这些，可以使用大数类或者其他工具类</li><li>绝不能将浮点变量用”==”或”!=”与任何 数字进行比较</li></ul><p>推荐个网址：<a href="https://babbage.cs.qc.cuny.edu/ieee-754.old/decimal.html">https://babbage.cs.qc.cuny.edu/ieee-754.old/decimal.html</a></p><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><ul><li>String字符串属于对象类型</li><li>基本数据类型之外的所有数据都属于引用数据类型</li><li>两个String字符串对象比较需要从内存进行分析，会在后续完善中补上</li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li>在运算过程中，所有不同类型的数据会先转换成同一类型，然后进行转换</li><li>在Java中，整数默认类型是int,浮点型默认类型是double</li></ul><p>所有基本类型按照所占空间大小进行比较：</p><p>低–&gt;高 </p><p>byte–&gt;char,short–&gt;int–&gt;long</p><p>float–&gt;double</p><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><ul><li><p>char是16位无符号Java基元数据类型，范围是0-65536，没有负数，因此byte,short不能自动转换为char</p></li><li><p>整数类型可以自动转换成浮点类型，浮点类型转换成整数类型需要强转</p></li></ul><h4 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h4><p>高类型 –&gt; 低类型</p><p><code>int a = 12; byte b = (byte)a</code></p><h4 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h4><p>低类型 –&gt; 高类型</p><h4 id="转换注意"><a href="#转换注意" class="headerlink" title="转换注意"></a>转换注意</h4><ol><li>不能对布尔类型进行转换</li><li>不能把对象类型转换成不相干的类型</li><li>强制转换时可能存在内存溢出和精度损失</li><li>高容量转换成低容量时必须使用强制转换</li></ol><ul><li>注意long类型规范使用L而不是l更加直观</li></ul><h2 id="变量、常量、作用域"><a href="#变量、常量、作用域" class="headerlink" title="变量、常量、作用域"></a>变量、常量、作用域</h2><p>常量和变量在空间分配上有很大的区别，后续详细讲解</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Java变量是程序中最基本的存储单元，其包括变量名，变量类型和作用域，在Java中分为类变量，实例变量，局部变量等</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> String name <span class="token operator">=</span> <span class="token string">"remmeiko"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//类变量</span>    <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//实例变量</span>    <span class="token comment" spellcheck="true">//数据类型 变量名 = 数据</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//局部变量</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>实例变量：属于对象，具有默认值</p><p><strong>static、final等修饰符不存在先后顺序</strong></p><h3 id="常量-Constant"><a href="#常量-Constant" class="headerlink" title="常量(Constant)"></a>常量(Constant)</h3><ul><li><p>常量名一般使用大写字符</p></li><li><p>是一种特殊的变量，它的值被设定后，在程序运行过程中不允许改变</p></li></ul><h2 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h2><table><thead><tr><th>运算符名称</th><th>运算符</th></tr></thead><tbody><tr><td>算数运算符</td><td>+,-,*,/,%,++,–</td></tr><tr><td>赋值运算符</td><td>=</td></tr><tr><td>关系运算符</td><td>&gt;,&lt;,&gt;=,&lt;=,==,!instanceof</td></tr><tr><td>逻辑运算符</td><td>&amp;&amp;,||,!</td></tr><tr><td>位运算符</td><td>&amp;,|,~,&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;</td></tr><tr><td>条件运算符</td><td>?:</td></tr><tr><td>扩展赋值运算符</td><td>+=,-=,*=,/=</td></tr></tbody></table><p>++ – 也被称为一元运算符</p><h2 id="包机制"><a href="#包机制" class="headerlink" title="包机制"></a>包机制</h2><p>一般使用公司域名倒置作为包名,是用来区分类名的命名空间</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>remmeiko<span class="token punctuation">.</span>www<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 导入包</span></code></pre><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://zhuanlan.zhihu.com/p/101237700">你知道Java语言布尔(boolean)型数据到底占多大空间吗?</a></p><p><a href="https://segmentfault.com/a/1190000012175422">为什么0.1+0.2不等于0.3</a></p><p><a href="https://www.zhihu.com/question/46432979/answer/221485161">java浮点类型float和double的主要区别，它们的小数精度范围大小是多少？</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 广度 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Node.js的简单学习</title>
      <link href="1Node.js/"/>
      <url>1Node.js/</url>
      
        <content type="html"><![CDATA[<p><strong><font size=6>知识需要足够的广度和一定的深度</font></strong></p><blockquote><p>前言：因为搭建博客接触到node.js，所以对node.js进行简单的了解，扩充一下广度同时记录一些大佬的文章方便自己日后查询，记录如下：</p></blockquote><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><h3 id="Node-js是什么"><a href="#Node-js是什么" class="headerlink" title="Node.js是什么"></a>Node.js是什么</h3><p>官方文档：<a href="http://nodejs.cn/learn">http://nodejs.cn/learn</a><br>下面是官方文档首段的介绍　　　　　　　　　　　　　<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%B8%80%E7%AF%87(Node.js%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0)/9-%E5%AE%98%E7%BD%91%E4%BB%8B%E7%BB%8D.png"></p><ul><li>Node.js是一个基于Chrome V8引擎的能够在服务器运行JavaScript的跨平台JavaScript运行环境(可以理解为服务端的的JavaScript的代码解析器)</li><li>Node.js采用事件驱动，非阻塞I/O模型（对于这方面的理解，我只知道因为JS是单线程的，不像Java中有多线程）</li><li>node中一部分就是V8引擎，用来解释JS代码，另一部分是封装了大量的工具库，可以用来实现各种文件操作、操作系统、程序等等，因此可以说node打通了JavaScript的前后端。</li><li>node可以用来作为中间层调用分发数据接口，像淘宝服务器后台是Java，在服务器在下面还设置有Node.js搭建在服务器</li></ul><blockquote><p>浏览器中存在着渲染引擎和JS引擎，JS引擎是用来解释JavaScript执行语言的</p></blockquote><blockquote><p>Node.js为JavaScript提供了操作文件、创建Http服务，创建TCP/UDP服务等的接口，让JavaScript可以完成其他后台语言(Java,python等)的工作，譬如对文件操作，处理数据库等。为了安全浏览器中JavaScript是无法实现这些功能的</p></blockquote><blockquote><p>我们经常说Node.js打通了JavaScript的前端和后端，其实原因就是在Node.js出现之前JS是一项完全的客户端技术，被用于浏览器中的各种动画加载，界面交互，对DOM操作等，而后端，即服务端完全是由JAVA等语言实现，在node.js出现后为其提供了上述所说的功能，使得前后端使用同一种语言成为了可能。</p></blockquote><h3 id="node-js能用来做什么"><a href="#node-js能用来做什么" class="headerlink" title="node.js能用来做什么"></a>node.js能用来做什么</h3><ul><li>Web服务API，比如REST</li><li>实时多人游戏</li><li>后端Web服务，譬如跨域、服务端的请求</li><li>基于Web的应用</li><li>多客户端的通信，如即时通信</li><li>本地应用程序等等</li></ul><h3 id="npm介绍"><a href="#npm介绍" class="headerlink" title="npm介绍"></a><strong>npm介绍</strong></h3><blockquote><p>1.npm是随Node.js一起安装的包管理工具，看名字就知道是用来对包进行管理的<br>2.npm允许用户从npm服务器下载和安装第三包进行使用，用户也可以自己编写包进行上传一起丰富这个庞大的生态系统</p></blockquote><ol><li>是全球最大的开源库生态系统<blockquote><p>对于包：在Node.js中一个js文件就可以成为一个模块，将多个模块放在一起完成特定功能就可以看作成一个包，使用npm包管理工具可以在工程中快捷的安装、引入自己需要的包,在安装过程中npm还会将目标包中所依赖的其他包一并下载</p></blockquote></li><li>类似Java语法中的maven，gradle，python中的pip</li></ol><blockquote><p>命令使用</p></blockquote><pre class=" language-JavaScript"><code class="language-JavaScript">// 查看npm的命令列表npm help// 查看npm的版本npm -v// 查看npm的配置（设置全局模块，镜像源，缓存，都可以进行查看是否成功）npm config ls -l</code></pre><blockquote><p>初始化命令</p><ul><li>将当前目录作为工作空间  </li><li>在当前目录下创建一个package.json文件，用来记录名字，版本，依赖等信息。 </li><li>不加-y参数在创建package.json过程中会让你设置名字，版本，依赖等信息，加上后不会提问会直接默认创建</li></ul></blockquote><pre class=" language-JavaScript"><code class="language-JavaScript">npm initnpm init -y</code></pre><p>下面是加上-y后默认创建的package.json中的内容<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%B8%80%E7%AF%87(Node.js%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0)/10-%E9%BB%98%E8%AE%A4%E5%88%9B%E5%BB%BA%E7%9A%84packagejson%E6%96%87%E4%BB%B6.png" alt="默认内容"></p><blockquote><p>安装第三方包（install）</p><ul><li>这是npm非常重要也是使用得非常多的功能  </li><li>安装包时会将包下载至node_modules目录中(不存在会自动创建)  </li><li>安装时候不加-g参数会默认安装在当前目录下</li><li>安装的时候加-g参数则是全局安装，会安装至设置的node_global中</li></ul></blockquote><pre class=" language-JavaScript"><code class="language-JavaScript">// 安装本地包npm install 包名// 安装全局包 npm install 包名 -g// --save参数(加上此参数会将包信息写进package.json的dependencies中)npm install 包名 --save// --save-dev参数(加上此参数会将包信息添加到package.json的devDependencies中)npm install 包名 --save-dev</code></pre><blockquote><p>dependencies与devDependenices  </p><ul><li>都是指定项目依赖的包</li><li>dependencies——这些包是需要发布到生产环境中去的，devDependencies——这些包只用于开发环境，不用于生产环境<br>【eg】:一个项目需要依赖于JQuery,没有这个包依赖运行就会报错，这时候需要将依赖写进dependenies。如果这个包只在开发测试过程中需要，上线后就不需要了，就写进devDependencies中</li></ul></blockquote><blockquote><p>卸载包(uninstall)【和安装相反其他一样】</p></blockquote><pre class=" language-JavaScript"><code class="language-JavaScript">// 卸载本地包npm uninstall 包名// 卸载全局包 npm uninstall 包名 -g// --save参数(加上此参数会将包信息写进package.json的dependencies中)npm uninstall 包名 --save// --save-dev参数(加上此参数会将包信息添加到package.json的devDependencies中)npm uninstall 包名 --save-dev</code></pre><p>npm学习网站：<a href="https://www.runoob.com/nodejs/nodejs-npm.html">https://www.runoob.com/nodejs/nodejs-npm.html</a></p><h2 id="node-js安装和配置"><a href="#node-js安装和配置" class="headerlink" title="node.js安装和配置"></a>node.js安装和配置</h2><blockquote><p><font face="Helvetica">安装Node.js此处介绍两种安装方式，一是通过msi程序引导安装，另一种是通过下载压缩包自己配置环境变量进行安装</font></p></blockquote><blockquote><p>新版的node.js自带npm，安装时会同时安装npm</p></blockquote><h3 id="引导程序安装："><a href="#引导程序安装：" class="headerlink" title="引导程序安装："></a><strong>引导程序安装</strong>：</h3><ul><li><p>第一步：在<a href="https://nodejs.org/zh-cn/">官网</a>下载node的msi程序安装文件。<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%B8%80%E7%AF%87(Node.js%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0)/1-%E5%AE%98%E7%BD%91%E7%95%8C%E9%9D%A2.png" alt="官网界面"></p></li><li><p>第二步:双击进入安装过程,正常情况下下一步就行了<br>其中有两个过程需要注意<br>  第一：安装模块的选择<br>  <img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%B8%80%E7%AF%87(Node.js%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0)/2-%E5%AE%89%E8%A3%85%E9%80%89%E6%8B%A9.png"><br>  Node.js runtime是Node.js的核心模块<br>  npm package manager是包管理工具<br>  Online documentation shortcut是相关介绍文档<br>  Add to PATH是将node和npm添加到环境变量<br>  <strong>默认就行</strong><br>  第二：<br>  <img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%B8%80%E7%AF%87(Node.js%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0)/3-%E5%AE%89%E8%A3%85%E9%80%89%E6%8B%A9.png"><br>  勾选后会自动安装2个工具，Python 2和Visual Studio构建工具,这两个构建工具是因为一些npm模块需要使用C/C++编译，如果想要编译这些模块则需要安装，不安装的话后续碰到这些模块会出问题，建议直接勾选避免不必要的麻烦，虽然后续可以手动安装</p><blockquote><p>关于这两个构建工具勾选后，Node.js安装完成后会跳出powershell窗口，光标一直会闪，不要关闭，会等一段时间才进行下载，如果安装失败就只能手动安装了。不过使用Node.js不是很多的话不安装也没什么大的影响。</p></blockquote></li><li><p>第三步:如果安装时勾选了Add to PATH，环境就已经安装完毕了，打开cmd窗口输入”node -v”和”npm -v”命令进行检测，如下图所示就是已经安装成功了<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%B8%80%E7%AF%87(Node.js%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0)/4-%E6%B5%8B%E8%AF%95%E5%AE%89%E8%A3%85.png" alt="测试图片"></p><h3 id="压缩包安装"><a href="#压缩包安装" class="headerlink" title="压缩包安装"></a><strong>压缩包安装</strong></h3><blockquote><p>通过下载压缩包进行安装（这是我最喜欢的方式）</p></blockquote></li><li><p>第一步：还是在<a href="https://nodejs.org/zh-cn/download/">官网</a>下载压缩包<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%B8%80%E7%AF%87(Node.js%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0)/5-%E5%8E%8B%E7%BC%A9%E5%8C%85%E4%B8%8B%E8%BD%BD.png" alt="下载界面"></p></li><li><p>下载解压后和第一种方式安装的内容是一样的</p></li><li><p>第二步：配置环境变量<br>将解压的目录路径添加到用户变量的path中去<br>如图：<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%B8%80%E7%AF%87(Node.js%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0)/6-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE.png" alt="环境变量"><br>到这里基本工作已经做完，在cmd中输入”node -v”和”npm -v”此时应该是已经能够正常显示的</p></li></ul><h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a><strong>其他配置</strong></h3><blockquote><p>上述两种方式中无论选择哪种方式都是一样的，安装好后就进行接下来的操作</p></blockquote><blockquote><p>在后续使用npm命令(如npm install 模块名 -g)[-g 是代表全局安装的参数，具体可以看npm的相关介绍]会默认安装在【C:\Users\用户名\AppData\Roaming\npm】占用C盘空间,接下来是设置为自定义路径 </p></blockquote><blockquote><p>此处是以第二种方式进行说明</p></blockquote><ul><li>配置npm安装模块时全局模块以及缓存cache的路径<ul><li>在安装的node文件下新建node_cache和node_global两个文件夹<br>然后在cmd中输入以下两行命令  <pre><code>npm config set prefix &quot;node_global路径&quot;  npm config set cache &quot;node_cache路径&quot;</code></pre><img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%B8%80%E7%AF%87(Node.js%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0)/7-%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84%E6%9B%B4%E6%94%B9.png" alt="命令输入"></li></ul></li><li>配置安装模块的镜像源  <ul><li>在cmd中使用命令 <pre><code>npm config set registry https://registry.npm.taobao.org --global</code></pre></li><li>进行验证,命令：npm config ls -l<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%B8%80%E7%AF%87(Node.js%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0)/8--%E6%9B%B4%E6%8D%A2%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F.png" alt="更换配置"></li></ul></li></ul><blockquote><p>之所以更换镜像源是因为npm的默认镜像源是在国外，由于网络的原因会安装失败，因此更换为淘宝的镜像源(<a href="https://registry.npm.taobao.org/&quot;">https://registry.npm.taobao.org/&quot;</a>) </p></blockquote><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="JS介绍"><a href="#JS介绍" class="headerlink" title="JS介绍"></a>JS介绍</h3><blockquote><p>此处只做简单介绍，毕竟此文章是作为知识广度的扩充</p></blockquote><blockquote><p>建议仔细阅读阮一峰的JavaScript诞生记<br><a href="http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html">http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html</a><br>知乎上关于JavaScript是什么<br><a href="https://www.zhihu.com/question/19813265">https://www.zhihu.com/question/19813265</a></p></blockquote><p>JavaScript是什么呢？下面开始扯名词</p><ul><li>JavaScript是一种轻量级的解释型脚本语言<blockquote><p>何为脚本语言  </p><ol><li>介于标记语言和编程语言之间的一种语言</li><li>灵活，语法和结构规则没有编程语言那么严谨和复杂，学习和使用相对简单</li><li>属于解释性语言(相对的是编译型语言)，由解释器进行解释  </li></ol><ul><li>注：现在很多脚本语言已经不止停留于编写简单的用户命令序列的指令，可以编写更为复杂的程序， <strong>脚本语言和编程语言没有明显的界限和规定</strong></li></ul></blockquote></li><li>是一门基于原型，函数先行的语言</li></ul><blockquote><p>基于原型的粗略理解就是JavaScript中是没有Class的，而是直接使用对象。</p></blockquote><blockquote><p>阮一峰JavaScript诞生记部分内容：  </p><ul><li>Javascript中没有类(Class)的概念，因此也就没有”子类”和”父类”的概念，存在一种”原型链”模式来实现继承 <strong>JS虽然没有类，但是存在继承</strong>  </li><li>历史诞生记：  <ol><li>JS是由网景公司(Netscape)的工程师Brendan Eich负责开发  </li><li>诞生的原因：在JS出现之前，浏览器只能用来进行浏览，无法与使用者进行互动，网景公司需要一种网页脚本实现浏览器与网页的互动</li><li>在此时1994年，面向对象编程最兴盛时期，Sun公司与网景结成联盟，允许Java程序以applet（小程序）的形式，直接在浏览器中运行。但是现在Java和JavaScript没有任何关系</li><li>设计之初要求该语言要简单，易于上手</li></ol></li><li>最终JS涵盖了两种语言风格：(简化)函数式编程和(简化)面向对象编程</li><li>JS构造对象，没有类的概念，所以构造对象时new后面直接跟构造函数，例如：<br>  function DOG(name) {<pre><code>  this.name = name;</code></pre>  }</li><li>对于其他的例如prototype和__proto__如果想要学习JS需要找其他资料</li></ul></blockquote><ul><li>浏览器中的JavaScript不提供对内存或CPU的底层访问，IO操作等，进行这些操作或者更复杂的操作需要借助Node.js等运行环境</li></ul><blockquote><p>吐糟：第一篇博客，还有许多地方需要改进，目前只能自己作为日后回顾时学习。(ps：前面的几篇都是搭建博客时测试用的草稿一样，不能算博客，本来想删的，思来想去还是留着吧，当个挂件)</p></blockquote><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>其他大佬的文章：<br>node.js学习：<a href="https://www.w3cschool.cn/nodejs/node-js-npm.html">https://www.w3cschool.cn/nodejs/node-js-npm.html</a><br>网址：<a href="https://juejin.cn/post/6844903906116370445">https://juejin.cn/post/6844903906116370445</a><br>Node.js:<a href="https://segmentfault.com/a/1190000006121183">https://segmentfault.com/a/1190000006121183</a><br>V8引擎：<a href="https://zhuanlan.zhihu.com/p/27628685">https://zhuanlan.zhihu.com/p/27628685</a><br>V8引擎如何工作：<a href="https://blog.fundebug.com/2019/07/16/how-does-v8-work/">https://blog.fundebug.com/2019/07/16/how-does-v8-work/</a><br>npm命令：<a href="https://www.cnblogs.com/hongdada/p/9144668.html">https://www.cnblogs.com/hongdada/p/9144668.html</a><br>Node.js安装:<a href="https://www.cnblogs.com/liangxfng/p/12675115.html">https://www.cnblogs.com/liangxfng/p/12675115.html</a><br><a href="https://zhuanlan.zhihu.com/p/77594251">https://zhuanlan.zhihu.com/p/77594251</a></p>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> 前端 </tag>
            
            <tag> 广度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环境配置</title>
      <link href="3%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>3%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p> <font color=white><strong>关于C盘索引路径和软件安装的插件:当卸载软件时,软件的这些文件不一定会删除,再次安装时可以直接读取和使用,因此人为改变后卸载软件最好及时删除或者下次重新安装时记得更改配置文件</strong></font></p><h3 id="Intellij-IDEA-2019-3-1"><a href="#Intellij-IDEA-2019-3-1" class="headerlink" title="Intellij IDEA 2019.3.1"></a>Intellij IDEA 2019.3.1</h3><h5 id="一-更改默认插件安装位置"><a href="#一-更改默认插件安装位置" class="headerlink" title="(一)更改默认插件安装位置"></a>(一)更改默认插件安装位置</h5><ul><li><p>Intellij IDEA安装在F盘Self_installing_Software文件夹中(这里)</p></li><li><p>idea自带的插件在idea安装目录的plugins目录中</p><blockquote><p>F:\Self_installing_Software\IntelliJ IDEA\IntelliJ IDEA 2019.3.1\plugins</p></blockquote></li><li><p>idea用户安装(非自带)的插件,默认在用户的 <strong>C:\Users\计算机名.IntelliJIdea2019.3\config\plugins</strong> 目录下</p><blockquote><p>C:\Users\Lenovo.IntelliJIdea2019.3\config\plugins</p></blockquote></li><li><p>听说2020年的Intellij IDEA安装的插件默认在:<br>C:\Users\Administrator\AppData\Roaming\JetBrains\IntelliJIdea2020.1\plugins</p></li><li><p>重点:更换默认安装目录</p><ol><li><p>进入idea的安装目录,找到“idea.properties”文件；</p></li><li><p>修改图中所示的两个地方,(相对路径和绝对路径均可),后面的为路径,其中config/plugins和system文件夹为独立创建的<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/5-1%E6%9B%B4%E6%8D%A2%E8%B7%AF%E5%BE%84.png"></p><ul><li>其中plugins路径为更改后的插件安装路径</li><li>system文件夹估计时运行时读取和生成配置的文件</li></ul></li><li><p>将C盘中两个文件夹中的文件拷贝到对应的文件即可,关闭重启idea</p></li></ol></li><li><p>可参考网址:</p><blockquote><p><a href="https://www.cnblogs.com/xiaostudy/p/12452139.html">https://www.cnblogs.com/xiaostudy/p/12452139.html</a><br><a href="https://www.bmqy.net/1773.html">https://www.bmqy.net/1773.html</a></p></blockquote></li><li><p>更改软件索引网址可参考:(譬如Intellij IDEA的默认索引路径为C:\Users\用户.IntelliJIdea)</p><blockquote><p><a href="https://www.cnblogs.com/appleat/p/10097048.html">https://www.cnblogs.com/appleat/p/10097048.html</a></p></blockquote></li></ul><hr><h5 id="二-主题配置"><a href="#二-主题配置" class="headerlink" title="(二)主题配置"></a>(二)主题配置</h5><h6 id="1-idea设置代码彩色高亮显示"><a href="#1-idea设置代码彩色高亮显示" class="headerlink" title="1.idea设置代码彩色高亮显示"></a>1.idea设置代码彩色高亮显示</h6><ul><li><p><strong>设置主题</strong><br>1.下载主题(见附录) 代码高亮主题选择了SublimeMonoKai.jar</p><blockquote><p>代码高亮主题网址(主要是代码区域)<br><a href="https://github.com/guobinhit/intellij-idea-tutorial/tree/master/resources/idea-theme">https://github.com/guobinhit/intellij-idea-tutorial/tree/master/resources/idea-theme</a><br>  全局主题网址:<br><a href="http://color-themes.com/?view=index">http://color-themes.com/?view=index</a></p></blockquote><p>2.导入主题:File–&gt;Import Settings–&gt;选择下载的主题的jar包<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/5-1%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E4%B8%BB%E9%A2%98.jpg"><br>3.配置主题:File–&gt;Setting–&gt;Color Scheme–&gt;右边Scheme选择主题即可<br>  <img src="https://remmeiko.gitee.io/img-bed/boke-img/5-2%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E4%B8%BB%E9%A2%98.jpg"></p></li><li><p><strong>删除主题</strong><br>1.主题配置文件的位置默认在C:\Users\计算机名.IntelliJIdea2018.2\config\colors目录下，找到相应的文件，并将其删除，重启 IntelliJ IDEA 后生效。<br>  <img src="https://remmeiko.gitee.io/img-bed/boke-img/5-3%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E4%B8%BB%E9%A2%98.jpg"></p></li><li><p>参考网址:</p><blockquote><p><a href="https://blog.csdn.net/Liu_xud/article/details/84190828">https://blog.csdn.net/Liu_xud/article/details/84190828</a><br><a href="https://blog.csdn.net/macSun_jh/article/details/81294235">https://blog.csdn.net/macSun_jh/article/details/81294235</a><br><a href="https://blog.csdn.net/qq_35246620/article/details/79056530">https://blog.csdn.net/qq_35246620/article/details/79056530</a></p></blockquote></li></ul><h6 id="2-设置全局主题"><a href="#2-设置全局主题" class="headerlink" title="2.设置全局主题"></a>2.设置全局主题</h6><ul><li>可以采取和上述一致的方法进行设置,也可以采取下述方法进行设置</li><li><strong>使用idea插件设置</strong> –&gt;<strong>Material Theme UI</strong>(把IDEA变得更加美观)</li><li>*步骤:** File–&gt;Settings–&gt;Plugins–&gt;搜索Material Theme UI–&gt;安装–&gt;重启</li><li>具体搭配很多样化,需要自行配置,下面是效果图(下面附带有自定义背景图):<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/5-4%E9%85%8D%E7%BD%AE%E4%B8%BB%E9%A2%98.jpg"></li><li>参考网址:(网址中还有一种通过网站下载插件再安装的方法)<blockquote><p><a href="https://blog.csdn.net/h13245/article/details/104847491/">https://blog.csdn.net/h13245/article/details/104847491/</a></p></blockquote></li></ul><h6 id="3-自定义背景图片"><a href="#3-自定义背景图片" class="headerlink" title="3.自定义背景图片"></a>3.自定义背景图片</h6><ul><li>默认背景是无背景设置</li><li>大致步骤<ul><li>设置搜索Set Backgroud Image</li><li>选择右边出现的黄色字体右键设置快捷键(Ctrl+Alt+0)(建议设置)</li><li>在弹出来是设置中便可以设置背景,附有一些相关设置</li></ul></li><li>设置网址:<blockquote><p><a href="https://blog.csdn.net/qq_42183409/article/details/90612098">https://blog.csdn.net/qq_42183409/article/details/90612098</a></p></blockquote></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Intellij IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Intellij IDEA </tag>
            
            <tag> 界面外观 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程问题</title>
      <link href="2%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98/"/>
      <url>2%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="编程问题"><a href="#编程问题" class="headerlink" title="编程问题"></a>编程问题</h1><h3 id="一-IDEA-错误-找不到或无法加载主类-解决方法"><a href="#一-IDEA-错误-找不到或无法加载主类-解决方法" class="headerlink" title="(一) IDEA 错误: 找不到或无法加载主类 解决方法"></a>(一) IDEA 错误: 找不到或无法加载主类 解决方法</h3><ul><li>问题描述:运行程序过程中报上述错误</li><li>可能原因:未能成功编译或者缓存问题</li><li>大致步骤<ul><li>菜单–&gt;Build–&gt;Rebuild Prodject</li><li>清除缓存在重构:菜单–&gt;File–&gt;Invalidate Caches/Restart 选择Invalidate and Restart或者只是Invalidate，清除掉缓存，然后Rebuild Project</li></ul></li><li>解决网址:<blockquote><p><a href="https://blog.csdn.net/kevinxxw/article/details/88647617">https://blog.csdn.net/kevinxxw/article/details/88647617</a></p></blockquote></li></ul><hr><h3 id="二-Intellij-IDEA-配置Maven项目环境"><a href="#二-Intellij-IDEA-配置Maven项目环境" class="headerlink" title="(二) Intellij IDEA 配置Maven项目环境"></a>(二) Intellij IDEA 配置Maven项目环境</h3><h6 id="Intellij-IDEA-配置Maven环境"><a href="#Intellij-IDEA-配置Maven环境" class="headerlink" title="Intellij IDEA 配置Maven环境:"></a>Intellij IDEA 配置Maven环境:</h6><ul><li><p>1.下载apache-maven文件,网址:</p><blockquote><p><a href="http://maven.apache.org/index.html">http://maven.apache.org/index.html</a></p></blockquote></li><li><p>2.解压,配置环境变量,高级设置中…</p><blockquote><p>a.MAVEN_HOME:D:\server\maven\apache-maven-3.5.0<br>b.PATH:%MAVEN_HOME%\bin;</p></blockquote></li><li><p>3.cmd输入mvn -v出现下列信息,则配置成功<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/1-mvn.jpg"></p></li><li><p>4.修改Maven仓库路径</p></li></ul><ul><li>在下载的Maven的路径中(F:\Self_installing_Software\18_Maven\apache-maven-3.6.3-bin\apache-maven-3.6.3-bin\apache-maven-3.6.3\conf)找到setting.xml文件,<br>设置如下:<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/SETTINGS/1.0.0<span class="token punctuation">"</span></span><span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span><span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pluginGroups</span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>proxies</span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servers</span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>localRepository</span><span class="token punctuation">></span></span>D:/server/maven/repository<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>localRepository</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirrors</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirror</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>alimaven<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirrorOf</span><span class="token punctuation">></span></span>central<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirrorOf</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>aliyun maven<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">></span></span>http://maven.aliyun.com/nexus/content/repositories/central/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirror</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirror</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>alimaven<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>aliyun maven<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">></span></span>http://maven.aliyun.com/nexus/content/groups/public/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirrorOf</span><span class="token punctuation">></span></span>central<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirrorOf</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirror</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirror</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>central<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>Maven Repository Switchboard<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">></span></span>http://repo1.maven.org/maven2/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirrorOf</span><span class="token punctuation">></span></span>central<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirrorOf</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirror</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirror</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>repo2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirrorOf</span><span class="token punctuation">></span></span>central<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirrorOf</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>Human Readable Name for this Mirror.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">></span></span>http://repo2.maven.org/maven2/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirror</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirror</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>ibiblio<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirrorOf</span><span class="token punctuation">></span></span>central<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirrorOf</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>Human Readable Name for this Mirror.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">></span></span>http://mirrors.ibiblio.org/pub/mirrors/maven2/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirror</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirror</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>jboss-public-repository-group<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirrorOf</span><span class="token punctuation">></span></span>central<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirrorOf</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>JBoss Public Repository Group<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">></span></span>http://repository.jboss.org/nexus/content/groups/public<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirror</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirror</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>google-maven-central<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>Google Maven Central<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">></span></span>https://maven-central.storage.googleapis.com  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirrorOf</span><span class="token punctuation">></span></span>central<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirrorOf</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirror</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 中央仓库在中国的镜像 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirror</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>maven.net.cn<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>oneof the central mirrors in china<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">></span></span>http://maven.net.cn/content/groups/public/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirrorOf</span><span class="token punctuation">></span></span>central<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirrorOf</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirror</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirrors</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">></span></span></code></pre>至此maven配置完毕,设置外部的 maven,其实Intellij自带有maven.<br>Idea自带了apache maven，默认使用的是内置maven，所以我们可以配置全局setting，来调整一下配置，比如远程仓库地址，本地编译环境变量等。</li></ul><ul><li><p>5.接下来是设置Intellj,打开Intellij IDEA,选择右下角的Configure设置,选择setting设置<br>ps:在不开任何项目的前提下设置是全局设置<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/2-Maven%E9%85%8D%E7%BD%AE.jpg"><br><img src="https://remmeiko.gitee.io/img-bed/boke-img/4-maven%E9%85%8D%E7%BD%AE.jpg"></p></li><li><p>6.上张图中右下角三处设置为下载的位置和配置</p></li><li><p>7.如果配置了本地apache-maven setting.xml 中的软件源，这步骤可以忽略,配置镜像源<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/4-maven%E9%85%8D%E7%BD%AE.png"></p></li><li><p>具体学习网址:(两网址参考对比配置环境)</p><blockquote><p><a href="https://blog.csdn.net/qq_32588349/article/details/51461182">https://blog.csdn.net/qq_32588349/article/details/51461182</a><br><a href="https://zhuanlan.zhihu.com/p/28133184">https://zhuanlan.zhihu.com/p/28133184</a></p></blockquote></li><li><p>附带其他相关网址:</p><blockquote><p><a href="https://www.tutorialspoint.com/maven/maven_environment_setup.htm">https://www.tutorialspoint.com/maven/maven_environment_setup.htm</a></p></blockquote></li><li><p>配置完毕创建第一个Maven项目参考网址:</p><blockquote><p><a href="https://cloud.tencent.com/developer/article/1105419">https://cloud.tencent.com/developer/article/1105419</a><br><a href="https://ken.io/note/java-quickstart-idea-maven-console">https://ken.io/note/java-quickstart-idea-maven-console</a></p></blockquote></li></ul><h3 id="三-Eclipse配置Maven详细教程"><a href="#三-Eclipse配置Maven详细教程" class="headerlink" title="(三) Eclipse配置Maven详细教程"></a>(三) Eclipse配置Maven详细教程</h3><ul><li>描述:Maven的配置和Intellij中的一致,其余参考网址配置</li><li>参考网址:<blockquote><p><a href="https://blog.csdn.net/wcc27857285/article/details/81812304">https://blog.csdn.net/wcc27857285/article/details/81812304</a></p></blockquote></li></ul><h3 id="四-通过maven添加Jar包"><a href="#四-通过maven添加Jar包" class="headerlink" title="(四) 通过maven添加Jar包"></a>(四) 通过maven添加Jar包</h3><ul><li><p>maven对Java项目管理最为方便一点便在于对引入包的管理,在pom.xml中添加代码,由代码去拉取插件和jar包添加到项目</p><h6 id="步骤"><a href="#步骤" class="headerlink" title="步骤:"></a>步骤:</h6></li><li><p>1.进入官网</p><blockquote><p><a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p></blockquote></li><li><p>2.输入你需要引入的包,例如jsoup,点击搜索,会显示对应的包,点击包<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/2-1maven%E5%BC%95%E5%85%A5%E5%8C%85.jpg"></p></li><li><p>3.选择需要的对应的版本,点击确认的框<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/2-2maven%E5%BC%95%E5%85%A5%E5%8C%85.jpg"></p></li><li><p>4.复制包的坐标<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/2-3maven%E5%BC%95%E5%85%A5%E5%8C%85.jpg"></p></li><li><p>5.复制至maven中的pom.xml中</p></li></ul><hr><h3 id="五-java操作Excel数据"><a href="#五-java操作Excel数据" class="headerlink" title="(五)java操作Excel数据"></a>(五)java操作Excel数据</h3><h5 id="1-运行错误"><a href="#1-运行错误" class="headerlink" title="1.运行错误"></a>1.运行错误</h5><ul><li>详细描述:<pre class=" language-java"><code class="language-java">Exception in thread <span class="token string">"main"</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>IncompatibleClassChangeError<span class="token operator">:</span> Found <span class="token keyword">interface</span> <span class="token class-name">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>poi<span class="token punctuation">.</span>util<span class="token punctuation">.</span>POILogger</span><span class="token punctuation">,</span> but <span class="token keyword">class</span> <span class="token class-name">was</span> expected</code></pre></li><li>原因:jar包版本不一致(pom.xml中poi版本不一致)ps:(也可能是jar包冲突,看到有博客介绍到)</li><li>解决:版本设置一致(<strong>version保证都是同一版,这里是4.1.2</strong>)<pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>dependency<span class="token operator">></span>  <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>poi<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>  <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>poi<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>  <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">4.1</span><span class="token punctuation">.</span><span class="token number">2</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span><span class="token operator">&lt;</span>dependency<span class="token operator">></span>  <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>poi<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>  <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>poi<span class="token operator">-</span>ooxml<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>  <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">4.1</span><span class="token punctuation">.</span><span class="token number">2</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span></code></pre></li><li>参考网址:<blockquote><p><a href="https://www.dazhuanlan.com/2019/09/08/1f9aa2a35c8e/">https://www.dazhuanlan.com/2019/09/08/1f9aa2a35c8e/</a></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Intellij IDEA </tag>
            
            <tag> Eclipse </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="hello-world/"/>
      <url>hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="博客前言"><a href="#博客前言" class="headerlink" title="博客前言"></a>博客前言</h2><p><strong>一些喃喃自语(声明)(2021.3.15.)</strong></p><blockquote><p><strong>这些博客对于互联网来说是一堆微不足道的数据，但对于我来说，我希望它能成为一个记录我现实生活中部分点滴的”家“，通过这些文字记录我曾存在于这个世界的证明，通过这些数据将我映射进这个虚拟的世界。因此，此博客除了记录技术学习之类的文章，后续也会杂七杂八记录很多关于我想留下或者分享的故事或者回忆，本来是打算将这些东西独立抽出来搭建一个网站，此博客只留下关于学习和技术记录的文章，但是目前没有时间所以暂时也不想去弄了。</strong></p><p>此博客目前也还没有被百度，谷歌收录，这些事情等以后将技术无关内容抽出来后肯定是会弄的。</p></blockquote><ul><li><strong>RemMeiko的小屋，昏暗光芒下的独自取暖</strong><ul><li>分享点滴</li><li>分享随想</li><li>记录互联网中留下的足迹</li><li>投射我所期望的世界</li></ul></li></ul><p><strong>博客正在搭建中……(8.8.)</strong></p><blockquote><p>前两篇博客是在搭建博客时拿来测试使用的，我更愿称之为数据，不用太在意</p></blockquote><h1 id="弱小和无知从来不是生存的障碍-傲慢才是"><a href="#弱小和无知从来不是生存的障碍-傲慢才是" class="headerlink" title="弱小和无知从来不是生存的障碍,傲慢才是"></a><strong>弱小和无知从来不是生存的障碍,傲慢才是</strong></h1><blockquote><p>于千万人之中遇见你所遇见的人，于千万年之中，时间的无涯的荒野里，没有早一步，也没有晚一步，刚巧赶上了，那也没有别的话可说，惟有轻轻的问一声：“噢，你也在这里吗？”</p><p>​                                                                                ——《流言》</p></blockquote><blockquote><p>每个人的生命中<br>都有无比艰难的那一年<br>将人生变得美好而辽阔。 </p></blockquote><blockquote><p>我慢慢明白了为什么我不快乐，因为我总是期待一个结果。<br>看一本书期待它让我变得深刻；吃饭、游泳期待它让我一斤斤瘦下；<br>发一条微信期待它被回复；对别人好期待被回待以好；<br>写一个故事说一个心情期待被关注安慰；参加一个活动，期待换来充实丰富的经历<br>这些预设的期待如果实现了，我长舒一口气，如果没有实现呢，就自怨自艾。<br>可是小时候也是同一个我，用一个下午的时间看蚂蚁搬家，等石头开花。<br>小时候不期待结果，小时候哭笑都不打折。<br>——–<a href="https://www.zhihu.com/question/361120282/answer/1172918310">知乎</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随手记 </tag>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
