<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux作业(俄罗斯方块Tetris)</title>
      <link href="Tetris(Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A11)/"/>
      <url>Tetris(Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A11)/</url>
      
        <content type="html"><![CDATA[<h1 id="Tetris-俄罗斯方块小游戏"><a href="#Tetris-俄罗斯方块小游戏" class="headerlink" title="Tetris(俄罗斯方块小游戏)"></a>Tetris(俄罗斯方块小游戏)</h1><ul><li>github地址：<a href="https://github.com/Gregwar/ASCII-Tetris.git">https://github.com/Gregwar/ASCII-Tetris.git</a></li><li>文件：<ul><li>main.c </li><li>tetris.c </li><li>tetris.h</li></ul></li></ul><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="1-terris-h"><a href="#1-terris-h" class="headerlink" title="1.terris.h"></a>1.terris.h</h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">ifndef</span> TETRIS_H</span><span class="token macro property"># <span class="token directive keyword">define</span> TETRIS_H</span><span class="token comment" spellcheck="true">// 定义了一个结构体</span><span class="token keyword">struct</span> tetris<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_cleanup_io</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_signal_quit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_set_ioconfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">,</span><span class="token keyword">int</span> w<span class="token punctuation">,</span><span class="token keyword">int</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_clean</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_print</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_run</span><span class="token punctuation">(</span><span class="token keyword">int</span> width<span class="token punctuation">,</span> <span class="token keyword">int</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_new_block</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_new_block</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_print_block</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_rotate</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_gravity</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_fall</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tetris_check_lines</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">tetris_level</span><span class="token punctuation">(</span><span class="token keyword">struct</span> tetris <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">//TETRIS_H</span></code></pre><p>这里面定义了一个tetris结构体，其他就是一些函数声明。参数基本上都是tetris结构体指针，关注tetris结构体和tetris_run方法(因为在main函数中被调用)，根据tetris_run调用其他函数的顺序逐渐分析其他函数</p><blockquote><p>C语言程序中，项目一般按功能模块化进行结构化设计，每个功能的相关程序放在一个C程序文档中，称之为一个模块。一个模块通常由两个文件组成，一个是头文件.h文件，包含了C函数声明和宏定义，简单来说就是对模块中的数据结构和函数原型进行描述，另一个则是.c文件，对数据实例或对象定义，以及函数算法具体实现。</p></blockquote><h3 id="2-main-c"><a href="#2-main-c" class="headerlink" title="2.main.c"></a>2.main.c</h3><pre class=" language-C"><code class="language-C">#include <stdio.h>#include <stdlib.h>#include <tetris.h>int main(void) &#123;    tetris_run(12, 15);    return EXIT_SUCCESS;&#125;</code></pre><p>main函数中只调用了tetris_run()方法，参数是两个int整数，看函数声明估计是宽度和长度。</p><h3 id="3-tetris-c"><a href="#3-tetris-c" class="headerlink" title="3.tetris.c"></a>3.tetris.c</h3><ul><li>这里只是简单贴一下tetris结构体</li></ul><pre class=" language-C"><code class="language-C">struct tetris &#123;    // 定义了一个二级指针    char **game;    // 宽度    int w;    // 高度    int h;    // 等级    int level;    // 游戏是否结束标志位    int gameover;    // 分数    int score;    // 定义了一个下坠俄罗斯方块的结构体    struct tetris_block &#123;        char data[5][5];        int w;        int h;    &#125; current;        int x;    int y;&#125;;</code></pre><ul><li>关于tetris_block结构体中下坠的俄罗斯方块的结构体相关的结构体数组(用于后面的俄罗斯方块随机下落)</li></ul><pre class=" language-C"><code class="language-C">// data[][],w,h// 形状，宽度，长度struct tetris_block blocks[] =&#123;    &#123;&#123;"##",          "##"&#125;,    2, 2    &#125;,    &#123;&#123;" X ",         "XXX"&#125;,    3, 2    &#125;,    &#123;&#123;"@@@@"&#125;,        4, 1&#125;,    &#123;&#123;"OO",         "O ",         "O "&#125;,    2, 3&#125;,    &#123;&#123;"&&",         " &",         " &"&#125;,    2, 3&#125;,    &#123;&#123;"ZZ ",         " ZZ"&#125;,    3, 2&#125;&#125;;</code></pre><h2 id="知识点介绍"><a href="#知识点介绍" class="headerlink" title="知识点介绍"></a>知识点介绍</h2><h3 id="timespec结构体"><a href="#timespec结构体" class="headerlink" title="timespec结构体"></a>timespec结构体</h3><p><code>  struct timespec tm;</code></p><blockquote><p>这是一个系统时钟的结构体数据类型，有两个成员，一个是秒，一个是纳秒，所以最高精确度是纳秒，函数定义：</p></blockquote><blockquote><p>struct timespec {<br>    time_t tv_sec; // seconds<br>    long tv_nsec; // and nanoseconds<br>};</p></blockquote><h3 id="srand-函数"><a href="#srand-函数" class="headerlink" title="srand()函数"></a>srand()函数</h3><p><code> srand(time(NULL));</code></p><blockquote><p>作用：进行重新播种</p></blockquote><blockquote><p>使用&lt;stdlib.h&gt;头文件中的rand函数产生伪随机数，int rand(void)</p></blockquote><blockquote><p>随机数的本质：rand() 函数产生的随机数是伪随机数，是根据一个数值按照某个公式推算出来的，这个数值我们称之为“种子”。种子和随机数之间的关系是一种正态分布，种子在每次启动计算机时是随机的，但是一旦计算机启动以后它就不再变化了；也就是说，每次启动计算机以后，种子就是定值了，所以根据公式推算出来的结果（也就是生成的随机数）就是固定的。</p></blockquote><blockquote><p>通过 srand() 函数来重新“播种”，这样种子就会发生改变。在实际开发中，我们可以用时间作为参数，只要每次播种的时间不同，那么生成的种子就不同，最终的随机数也就不同。使用 &lt;time.h&gt; 头文件中的 time() 函数即可得到当前的时间（精确到秒）。函数声明：</p></blockquote><blockquote><pre class=" language-C"><code class="language-C">void srand (unsigned int seed);</code></pre></blockquote><h3 id="nanosleep-函数"><a href="#nanosleep-函数" class="headerlink" title="nanosleep()函数"></a>nanosleep()函数</h3><p><code>   nanosleep(&amp;tm, NULL);</code></p><blockquote><p>nanosleep函数,暂停某个进程直到规定时间后恢复，参数rqtp是你定义的时间间隔，或者在指定时间间隔内有信号传递到当前线程。由于调用nanosleep是是进程进入TASK_INTERRUPTIBLE,这种状态是会相应信号而进入TASK_RUNNING状态的，这就意味着有可能会没有等到你规定的时间就因为其它信号而唤醒，此时函数返回-1，切还剩余的时间会被记录在rmtp中。函数原型：</p></blockquote><blockquote><p>#include &lt;time.h&gt;<br>int nanosleep(const struct timespec *rqtp, struct timespec *rmtp);</p><p>接受的参数是timespec 结构体数据类型,在前面介绍过</p></blockquote><h3 id="getchar-函数"><a href="#getchar-函数" class="headerlink" title="getchar()函数"></a>getchar()函数</h3><p><code>getchar()</code></p><ul><li>头文件：&lt;stdio.h&gt;</li><li>函数原型：int getchar(void)</li><li>返回值：以无符号 char 强制转换为 int 的形式返回读取的字符，如果到达文件末尾或发生读错误，则返回 EOF</li><li>函数原理：当程序调用getchar时，程序会阻塞，等着用户按键。用户输入的字符被存放在键盘缓冲区中。直到用户按回车为止。当用户键入回车之后，getchar才开始从缓冲区每次读入一个字符。getchar函数的返回值是用户输入的字符的ASCII码，若文件结尾则返回-1(EOF)，且将用户输入的字符回显到屏幕。如用户在按回车之前输入了不止一个字符，其他字符会保留在键盘缓存区中，等待后续getchar调用读取。也就是说，后续的getchar调用不会等待用户按键，而直接读取缓冲区中的字符，直到缓冲区中的字符读完后，才等待用户按键</li></ul><h3 id="malloc-函数"><a href="#malloc-函数" class="headerlink" title="malloc()函数"></a>malloc()函数</h3><ul><li><p>头文件: stdlib</p></li><li><p>函数原型：void *molloc(unsigned int size);</p></li><li><p>参数：无符号整数型unsigned int size，要分配的字节数</p></li><li><p>返回值：成功则返回分配空间的起始地址</p></li><li><p>注意：需要和free配套使用，防止内存泄漏</p></li></ul><blockquote><p>free函数原型: void free(void * ptr)</p></blockquote><h3 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h3><ul><li><p>这个程序中使用了两个坐标系：<strong>笛卡尔坐标系</strong>(整体界面)和<strong>行列式坐标系</strong>(俄罗斯方块)</p></li><li><p>这两个坐标系的区别个人理解就是，笛卡尔坐标系就是我们平常使用的坐标系，x坐标代表的是所在列，y代表的是所在行，</p></li><li><p>行列式刚好相反坐标系，x代表的是所在行，y代表的是坐在列</p></li></ul><blockquote><p>eg:一个3*3的网格，第二行第三个网格使用笛卡尔坐标系表示是(3，2)，采用行列式坐标系表示是(2，3)</p></blockquote><h2 id="程序函数分析"><a href="#程序函数分析" class="headerlink" title="程序函数分析"></a>程序函数分析</h2><h4 id="整体程序流程"><a href="#整体程序流程" class="headerlink" title="整体程序流程"></a>整体程序流程</h4><p><img src="https://remmeiko.gitee.io/img-bed/boke-img/Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%BD%9C%E4%B8%9A/(%E4%BD%9C%E4%B8%9A1)%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="整体流程图"></p><ul><li>下面是整个程序中使用到的部分函数</li></ul><h4 id="tetris-hittest函数"><a href="#tetris-hittest函数" class="headerlink" title="tetris_hittest函数"></a>tetris_hittest函数</h4><pre class=" language-C"><code class="language-C">int tetris_hittest(struct tetris *t) &#123;    int x,y,X,Y;    struct tetris_block b=t->current;    /*    双重循环 以俄罗斯方块的宽为第一重循环，俄罗斯方块的高为第二重循环，在分别加上其在整体界面上的x,y坐标，表示将区域限定在了俄罗斯小方块的界面上，并从左至右，从上至下进行遍历，对方块的每个格子进行判定    */    for (x=0; x<b.w; x++)        for (y=0; y<b.h; y++) &#123;            X=t->x+x;            Y=t->y+y;            // 方块是否越过左右边界            if (X<0 || X>=t->w)                return 1;            // 俄罗斯方块是否为空            if (b.data[y][x]!=' ') &#123;                // 判断俄罗斯方块的底层布局上是否已经有下落方块                if ((Y>=t->h) ||                         (X>=0 && X<t->w && Y>=0 && t->game[X][Y]!=' ')) &#123;                    return 1;                &#125;            &#125;        &#125;    return 0;&#125;</code></pre><ul><li>参数：tetris结构体指针</li><li>返回类型：int(0，1)—0代表正常返回，1代表异常结束返回</li><li>功能：主要是通过判定条件返回1或0，其他函数根据1或0进行功能的设计</li><li>在整个程序中被频繁使用,具体作用需要具体分析</li></ul><h4 id="tetris-print函数"><a href="#tetris-print函数" class="headerlink" title="tetris_print函数"></a>tetris_print函数</h4><pre class=" language-C"><code class="language-C">// 整个俄罗斯方块程序是一个终端程序，因此是采用间隔打印的方式来实现动态游戏的    // 意思就是每个一定的时间就会重新打印一次界面voidtetris_print(struct tetris *t) &#123;    int x,y;    // 打印30次回车空行来将上一次打印的界面给隐藏起来，毕竟一个屏幕也只能显示这么多行    for (x=0; x<30; x++)        printf("\n");    // 打印等级和分数    printf("[LEVEL: %d | SCORE: %d]\n", t->level, t->score);    for (x=0; x<2*t->w+2; x++)        printf("~");    printf("\n");        /*    重点就在这:因为这里还需要打印在整个界面中间打印俄罗斯方块，将整体界面当作一个棋盘，重点是if语句    使用的是双重for循环来遍历整个棋盘，遍历到的地方当作一个格子    x:棋盘的宽，从左边开始    y:棋盘的高，从上面开始    t->w:棋盘的整个宽度    t->h:棋盘的整个高度    t->x:俄罗斯方块在整个棋盘中的x坐标    t->y:俄罗斯方块在整个棋盘中的y坐标    t->current.w：俄罗斯方块的宽    t->current.h: 俄罗斯方块的高    先从y开始循环，就是从最上面一行开始    */    for (y=0; y<t->h; y++) &#123;        printf ("!");        for (x=0; x<t->w; x++) &#123;            /*            这里需要理解的是，前面说过这个程序是两个界面，一个是底层的整体界面，就是这个棋盘，另一个就是俄罗斯方块界面，是一个小的重叠在底层界面之上的一个独立界面。            这个循环就是将目标区域缩小在了俄罗斯方块这个小界面上(大于等于俄罗斯方块的x和y坐标，小于其位置加上俄罗斯方块的宽度和高度)，然后将这个小区域中非空的区域继续打印，其他地方即else所表示的地方打印game数组中存放的数据即可，就是打印空或者已经降下的俄罗斯方块。            */            if (x>=t->x && y>=t->y                     && x<(t->x+t->current.w) && y<(t->y+t->current.h)                     && t->current.data[y-t->y][x-t->x]!=' ')                printf("%c ", t->current.data[y-t->y][x-t->x]);            else                printf("%c ",t->game[x][y]);        &#125;        printf ("!\n");    &#125;        for (x=0; x<2*t->w+2; x++)        printf("~");    printf("\n");    printf(" 方块横坐标(t->x)：%d\n 方块纵坐标(t->y)：%d\n 方块的宽度(t->current.w)：%d\n 方块的长度(t->current.h)：%d\n",t->x,t->y,t->current.w,t->current.h);</code></pre><ul><li>参数：tetris结构体指针</li><li>返回类型：void</li><li>功能：打印整个游戏界面</li></ul><blockquote><p>整个程序是使用有两个界面，一个是底层的整体界面，还有一个就是俄罗斯方块的界面，但是计算机只能一行一行打印，因此打印的时候就需要设计一些简单的算法(譬如什么时候打印空格，什么时候打印俄罗斯方块等等)，具体可以看注释</p></blockquote><h4 id="tetris-print-block-函数"><a href="#tetris-print-block-函数" class="headerlink" title="tetris_print_block()函数"></a>tetris_print_block()函数</h4><pre class=" language-C"><code class="language-C">void tetris_print_block(struct tetris *t) &#123;    int x,y,X,Y;    struct tetris_block b=t->current;    /*    循环遍历整个俄罗斯方块界面，如果非空则存入game数组中    */    for (x=0; x<b.w; x++)        for (y=0; y<b.h; y++) &#123;            if (b.data[y][x]!=' ')                // 存入game数组中                t->game[t->x+x][t->y+y]=b.data[y][x];        &#125;&#125;</code></pre><ul><li>参数：tetris结构体指针</li><li>返回类型：void</li><li>功能：将已经下落☞最底层的俄罗斯方块存入game数组(底层接界面)中</li></ul><blockquote><p>这里有一点，就是程序中有一个tetris_gravity函数，用来控制方块下降使用的，除了加速调用过之外，每循环350次也会被调用一次，在这里会根据tetris_hittest()函数的返回结果决定是否调用tetris_hittest函数</p></blockquote><ul><li>在这个调用的时候，如果tetris_hittest()函数返回1则表示已经有方块存在了，说明已经到底了</li></ul><blockquote><p>其实一开始我也很好奇这个是怎样判断下落的下一个位置已经存在方块了。</p></blockquote><h4 id="tetris-gravity-函数"><a href="#tetris-gravity-函数" class="headerlink" title="tetris_gravity()函数"></a>tetris_gravity()函数</h4><pre class=" language-C"><code class="language-C">void tetris_gravity(struct tetris *t) &#123;    int x,y;    // 方块的的y坐标加1,表示额外下降一格，从视觉上就如加速一样    t->y++;    // 如果返回1 表示下一个+1的位置已经有方块了，不能在下降了    if (tetris_hittest(t)) &#123;        // y--将y重新设置回去        t->y--;        // 这个方块就此结束，已经触底了，将方块存入至game数组中        tetris_print_block(t);        tetris_new_block(t);    &#125;&#125;</code></pre><h4 id="白话文瞎说一通-23333"><a href="#白话文瞎说一通-23333" class="headerlink" title="白话文瞎说一通(23333)"></a>白话文瞎说一通(23333)</h4><ul><li>游戏界面 W*H    小俄罗斯方块界面  w *h </li></ul><p>流程：main方法调用tetris_run()函数，tetris_run()函数创建系统时间结构体tm和俄罗斯方块结构体t,tetris_set_ioconfig(),tetris_init()函数进行初始化，利用srand()产生随机数种子用于随机生成俄罗斯方块，接下来tetris_new_block()方法随机生成俄罗斯方块，方块生成位置为中间位置，整个界面的初始点是左上角，方块初始位置(W/2-w/2,0),根据gameover标志位的值判断游戏是否结束，未结束进入while循环，执行nanosleep休眠函数，定义记录变量count,循环一次加1，每50次调用一次tetris_print()函数打印界面，每350次会先后调用tetris_gravity()函数tetris_check_lines()函数来将方块的 位置加1和检查界面中是否有方块已经存满一行了，其中tetris_gravity()函数中有tetris_print_block()函数来将下落的方块存入game数组中，如果有则调用tetris_fall()方法消去，在while循环中同时定义了一个键盘扫描的while循环函数，通过getchar()获取键盘输入，getchar()函数前面有介绍，根据按下的按键执行对应的函数，s和w对应tetris_gravity()和tetris_rotate()函数。a和d则分别对于位置的x进行减加，同时每次调用tetris_hittest()函数进行检查。</p><h2 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h2><p><a href="http://c.biancheng.net/view/2043.html">srand和随机数</a></p><p><a href="https://baike.baidu.com/item/getchar%28%29/6876946?fr=aladdin">getchar函数</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 作业 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="Java%E5%9F%BA%E7%A1%80/"/>
      <url>Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>java中有三种注释：单行注释、多行注释和文档注释</p><ul><li>单行注释 <code>// 这是单行注释</code></li><li>多行注释   <code>/*这是多行注释*/</code></li><li>文档注释(Javadoc)    <code>/**这是文档注释*/</code></li></ul><p>文档注释只能放在类、接口、方法、构造器、成员字段之前，由描述部分和标记部分组成，描述部分和标记部分之间通过空行区分，是专门为javadoc工具自动生成文档而写的注释</p><p>里面含有一些特殊标签(简单列举)：</p><table><thead><tr><th>标签</th><th>描述</th><th>范围</th><th>示例</th></tr></thead><tbody><tr><td>@author</td><td>作者</td><td>文件、类、方法</td><td>@author remmeiko</td></tr><tr><td>@since</td><td>JDK版本</td><td>文件、类</td><td>@since 1.8</td></tr><tr><td>@version</td><td>软件版本号</td><td>文件、类、方法</td><td>@version 1.0.0</td></tr><tr><td>@param</td><td>方法参数</td><td>方法</td><td>@param 参数名称 参数描述</td></tr><tr><td>@return</td><td>方法返回值</td><td>方法</td><td>@return 返回值描述</td></tr></tbody></table><blockquote><p>程序中的文档注释遵守一定的规范，便可以通过Javadoc工具从源代码中抽取这些注释生成API帮助文档，Java帮助文档主要用来说明类、成员变量和方法的功能</p></blockquote><blockquote><p>使用Javadoc工具生成帮助文档：<code>  javadoc -encoding UTF-8 -charset UTF-8 java.java</code></p><p>使用Intellij开发工具:Tools–&gt;Generate JavaDoc–&gt;Other command line arguments输入-encoding UTF-8 -charset UTF-8设置编码格式–&gt;确定</p></blockquote><p><strong>写程序必须养成写注释的习惯，注释是程序的规范之一</strong></p><h2 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>Java语言中，类、接口、变量、常量、函数、语句块等名字统称为Java标识符，说白了就是Java语言中自己命名的名字。</p><p><code>String name = &quot;remmeiKo&quot;</code></p><p>在这个里面name就是标识符</p><h3 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h3><ul><li>标识符可以是字母(a-z,A-Z)，$符号或者下划线(_)或者数字的任何组合，但是<strong>数字不能作为标识符的开头</strong><ul><li>比如2u_d,u_d￥是非法的，u_d,u_d$是合法的标识符</li></ul></li><li>标识符是大小写敏感的</li><li>不能使用关键字作为名字(方法名、变量名等)</li><li>命名应该尽量使用英文并且做到见名知意</li></ul><h3 id="关键字-保留字"><a href="#关键字-保留字" class="headerlink" title="关键字(保留字)"></a>关键字(保留字)</h3><p>Java中具有特殊含义的标识符，不能用来作为方法名、包名等使用</p><p><img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%BA%8C%E7%AF%87/1-%E5%85%B3%E9%94%AE%E5%AD%97.png" alt="关键字"></p><p>在使用过程中会逐渐熟悉</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Java是一种强类型语言，其数据类型有两种，基本类型(primitive type)和引用类型(reference type)，第一次申明变量时必须申明变量类型</p><blockquote><p>强类型语言：强弱类型这个东西比较抽象和复杂，众说纷纭，百度百科说的是强类型指的是程序中表达的任何对象所从属的类型都必须能在编译时刻确定,任何变量在使用时必须指定该变量的类型,不经过强制转换，它永远是这个数据类型，不允许隐式的类型转换。</p><p>按照百度百科通俗理解的是Java应该是弱类型语言。所以我的理解就是倾向于类型转换的是弱类型语言，反之则是强类型语言。像弱类型语言类型转换是很随意的，布尔类型和其他类型也能相互转换。</p></blockquote><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>也被成为内置类型</p><ul><li>整数型<ul><li>byte，占用1个字节，范围：-128-127</li><li>short，占用2个字节，范围：-32768-32767</li><li>int，占用4个字节，范围：-2147483648-2147483647(20亿左右，一般整数使用int就够了)</li><li>long，占用8个字节，范围：-2^31~2^31-1</li></ul></li><li>浮点型<ul><li>float，占用4个字节</li><li>double，占用8个字节</li></ul></li><li>字符类型<ul><li>char，占用2个字节</li></ul></li><li>布尔类型<ul><li>boolean，只有如果虚拟机的实现按照规范来则在数组情况下占用1个字节，单个占用4个字节</li></ul></li></ul><blockquote><p>二进制的前缀是0b</p><p>八进制的前缀是0</p><p>十六进制的前缀是0x</p><p>比如2分别用二进制，八进制，十六进制表示是0b10，002 0x02</p></blockquote><h4 id="布尔类型扩展"><a href="#布尔类型扩展" class="headerlink" title="布尔类型扩展"></a>布尔类型扩展</h4><p><strong>if(flag == true) 和 if(flag)尽量采用后者</strong></p><p>关于布尔类型的大小有几种说法;</p><ul><li>1个bit位</li><li>1个字节</li><li>4个字节</li></ul><p>布尔类型只有true和false两个可能的值，也就是真和假，那么用0和1来表示就可以了，也就是说用一个bit位就足够了，但是计算机处理数据的最小单位是1个字节，（计算机寻址操作以字节为最小单位进行）也就是说实际存储的空间需要一个字节。别急，接着往下看：</p><blockquote><p>在《虚拟机规范》中对于布尔类型有专门的解释：“虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，（因此）每个boolean元素占8位”</p></blockquote><p>也就是说在数组情况下占用1个字节，单个占用4个字节</p><blockquote><p>这里要说一点，世界上制作了Java虚拟机(JVM)的除了Oracle公司还有许多公司，详情可以看<a href="https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines">维基百科JVM比较</a>,意思就是因为虚拟机的不同因此情况也可能需要另作讨论</p></blockquote><p>最后的结论就是：如果虚拟机遵守《虚拟机规范》，在数组情况下布尔类型占用1个字节，单个占用4个字节</p><h4 id="浮点型扩展"><a href="#浮点型扩展" class="headerlink" title="浮点型扩展"></a>浮点型扩展</h4><p>银行家业务，对于精确度高的场景使用大数类型，浮点型会出现舍入误差</p><p>先提一个问题：0.1+0.2=？</p><p>这句话会打印什么:<code>System.out.println(0.1+0.3);</code></p><p><img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%BA%8C%E7%AF%87/2-%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C.png" alt="打印结果"></p><p>打印出来的并不是0.3,为什么会这样？</p><h5 id="浮点数的存储"><a href="#浮点数的存储" class="headerlink" title="浮点数的存储"></a>浮点数的存储</h5><p>IEEE754标准中浮点数表示法是一种科学计数法，组成分为三部分：</p><ul><li><p>符号位(sign),用来区分浮点数的正负，0表示正数，1表示负数</p></li><li><p>指数位(exponent):用来存储指数，范围是0-255,因为指数可能为负数，为此实际指数位存储的是指数减去偏移量(需要转换成二进制)</p></li><li><p>尾数位(fraction)：保存尾数(这个尾数不仅包括小数部分)</p></li></ul><table><thead><tr><th>Type</th><th>符号位</th><th>指数位</th><th>尾数位</th><th>偏移量</th><th>总位数</th></tr></thead><tbody><tr><td>float</td><td>1位</td><td>8位</td><td>23位</td><td>127</td><td>32位</td></tr><tr><td>double</td><td>1位</td><td>11位</td><td>52位</td><td>1023</td><td>64位</td></tr></tbody></table><p><img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%BA%8C%E7%AF%87/3-float%E5%AD%98%E5%82%A8.png"></p><blockquote><p>科学计数法：举例–0.00213 科学计数法为2.13*10^-3  这里5是指数</p><p>浮点数也是一样，采用的是二进制，如采用二进制来表示整数和小数，举例100.10101—-&gt;科学计数法就是1.0010101*2^2</p><p>这里指数就是2,将其加上偏移量转换成二进制便得到了指数位</p><p>科学计数法中小数点后的便是尾数位，需要注意的是浮点型的尾数位数，当超过这个位数后便会直接截断舍去，这也是造成误差的原因。</p></blockquote><h5 id="存储计算"><a href="#存储计算" class="headerlink" title="存储计算"></a>存储计算</h5><p>以2.3这个小数为例，这里采用的是float型，我们计算一下在计算机中是如何以二进制存储的。</p><p>符号位：0    因为是正数</p><p>先将其化为二进制（乘2除整）：10.01001100110011001100110  (这里只取23位)</p><blockquote><p>2 –&gt; 10</p><p>0.3 –&gt; 01001100110011001100110</p></blockquote><p>再将其转换成科学计数：1.0010_0110_0110_0110_0110_011  * 2^1</p><p>我们看到其指数为1，将其加上偏移量127后为128，二进制是1000_0000，因此指数位为1000_0000</p><p>小数位：0010_0110_0110_0110_0110_011</p><p>最后结果：0 1000_0000 0010_0110_0110_0110_0110_011</p><h5 id="误差原因"><a href="#误差原因" class="headerlink" title="误差原因"></a>误差原因</h5><p>当我们把小数转换成二进制的时候，很多时候得到的是一个二进制无限循环小数，但是我们的浮点型对于尾数的位数却是有限的，当超过这个位数后面的数据便会被舍去，float的尾数是23位，double的尾数是52位，double比float精确度要高很多，但也是存在误差的，0.1+0.2!=0.3的前提是使用double型。</p><p><strong>二进制可以精确的表示位数有限并且分母是2的倍数的小数</strong></p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul><li>对于精确度比较高的项目或者场景就不能使用浮点型，浮点型会出现舍入误差例如银行业务这些，可以使用大数类或者其他工具类</li><li>绝不能将浮点变量用”==”或”!=”与任何 数字进行比较</li></ul><p>推荐个网址：<a href="https://babbage.cs.qc.cuny.edu/ieee-754.old/decimal.html">https://babbage.cs.qc.cuny.edu/ieee-754.old/decimal.html</a></p><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><ul><li>String字符串属于对象类型</li><li>基本数据类型之外的所有数据都属于引用数据类型</li><li>两个String字符串对象比较需要从内存进行分析，会在后续完善中补上</li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li>在运算过程中，所有不同类型的数据会先转换成同一类型，然后进行转换</li><li>在Java中，整数默认类型是int,浮点型默认类型是double</li></ul><p>所有基本类型按照所占空间大小进行比较：</p><p>低–&gt;高 </p><p>byte–&gt;char,short–&gt;int–&gt;long</p><p>float–&gt;double</p><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><ul><li><p>char是16位无符号Java基元数据类型，范围是0-65536，没有负数，因此byte,short不能自动转换为char</p></li><li><p>整数类型可以自动转换成浮点类型，浮点类型转换成整数类型需要强转</p></li></ul><h4 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h4><p>高类型 –&gt; 低类型</p><p><code>int a = 12; byte b = (byte)a</code></p><h4 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h4><p>低类型 –&gt; 高类型</p><h4 id="转换注意"><a href="#转换注意" class="headerlink" title="转换注意"></a>转换注意</h4><ol><li>不能对布尔类型进行转换</li><li>不能把对象类型转换成不相干的类型</li><li>强制转换时可能存在内存溢出和精度损失</li><li>高容量转换成低容量时必须使用强制转换</li></ol><ul><li>注意long类型规范使用L而不是l更加直观</li></ul><h2 id="变量、常量、作用域"><a href="#变量、常量、作用域" class="headerlink" title="变量、常量、作用域"></a>变量、常量、作用域</h2><p>常量和变量在空间分配上有很大的区别，后续详细讲解</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Java变量是程序中最基本的存储单元，其包括变量名，变量类型和作用域，在Java中分为类变量，实例变量，局部变量等</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> String name <span class="token operator">=</span> <span class="token string">"remmeiko"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//类变量</span>    <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//实例变量</span>    <span class="token comment" spellcheck="true">//数据类型 变量名 = 数据</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//局部变量</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>实例变量：属于对象，具有默认值</p><p><strong>static、final等修饰符不存在先后顺序</strong></p><h3 id="常量-Constant"><a href="#常量-Constant" class="headerlink" title="常量(Constant)"></a>常量(Constant)</h3><ul><li><p>常量名一般使用大写字符</p></li><li><p>是一种特殊的变量，它的值被设定后，在程序运行过程中不允许改变</p></li></ul><h2 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h2><table><thead><tr><th>运算符名称</th><th>运算符</th></tr></thead><tbody><tr><td>算数运算符</td><td>+,-,*,/,%,++,–</td></tr><tr><td>赋值运算符</td><td>=</td></tr><tr><td>关系运算符</td><td>&gt;,&lt;,&gt;=,&lt;=,==,!instanceof</td></tr><tr><td>逻辑运算符</td><td>&amp;&amp;,||,!</td></tr><tr><td>位运算符</td><td>&amp;,|,~,&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;</td></tr><tr><td>条件运算符</td><td>?:</td></tr><tr><td>扩展赋值运算符</td><td>+=,-=,*=,/=</td></tr></tbody></table><p>++ – 也被称为一元运算符</p><h2 id="包机制"><a href="#包机制" class="headerlink" title="包机制"></a>包机制</h2><p>一般使用公司域名倒置作为包名,是用来区分类名的命名空间</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>remmeiko<span class="token punctuation">.</span>www<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 导入包</span></code></pre><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://zhuanlan.zhihu.com/p/101237700">你知道Java语言布尔(boolean)型数据到底占多大空间吗?</a></p><p><a href="https://segmentfault.com/a/1190000012175422">为什么0.1+0.2不等于0.3</a></p><p><a href="https://www.zhihu.com/question/46432979/answer/221485161">java浮点类型float和double的主要区别，它们的小数精度范围大小是多少？</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 广度 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Node.js的简单学习</title>
      <link href="1Node.js/"/>
      <url>1Node.js/</url>
      
        <content type="html"><![CDATA[<p><strong><font size=6>知识需要足够的广度和一定的深度</font></strong></p><blockquote><p>前言：因为搭建博客接触到node.js，所以对node.js进行简单的了解，扩充一下广度同时记录一些大佬的文章方便自己日后查询，记录如下：</p></blockquote><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><h3 id="Node-js是什么"><a href="#Node-js是什么" class="headerlink" title="Node.js是什么"></a>Node.js是什么</h3><p>官方文档：<a href="http://nodejs.cn/learn">http://nodejs.cn/learn</a><br>下面是官方文档首段的介绍　　　　　　　　　　　　　<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%B8%80%E7%AF%87(Node.js%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0)/9-%E5%AE%98%E7%BD%91%E4%BB%8B%E7%BB%8D.png"></p><ul><li>Node.js是一个基于Chrome V8引擎的能够在服务器运行JavaScript的跨平台JavaScript运行环境(可以理解为服务端的的JavaScript的代码解析器)</li><li>Node.js采用事件驱动，非阻塞I/O模型（对于这方面的理解，我只知道因为JS是单线程的，不像Java中有多线程）</li><li>node中一部分就是V8引擎，用来解释JS代码，另一部分是封装了大量的工具库，可以用来实现各种文件操作、操作系统、程序等等，因此可以说node打通了JavaScript的前后端。</li><li>node可以用来作为中间层调用分发数据接口，像淘宝服务器后台是Java，在服务器在下面还设置有Node.js搭建在服务器</li></ul><blockquote><p>浏览器中存在着渲染引擎和JS引擎，JS引擎是用来解释JavaScript执行语言的</p></blockquote><blockquote><p>Node.js为JavaScript提供了操作文件、创建Http服务，创建TCP/UDP服务等的接口，让JavaScript可以完成其他后台语言(Java,python等)的工作，譬如对文件操作，处理数据库等。为了安全浏览器中JavaScript是无法实现这些功能的</p></blockquote><blockquote><p>我们经常说Node.js打通了JavaScript的前端和后端，其实原因就是在Node.js出现之前JS是一项完全的客户端技术，被用于浏览器中的各种动画加载，界面交互，对DOM操作等，而后端，即服务端完全是由JAVA等语言实现，在node.js出现后为其提供了上述所说的功能，使得前后端使用同一种语言成为了可能。</p></blockquote><h3 id="node-js能用来做什么"><a href="#node-js能用来做什么" class="headerlink" title="node.js能用来做什么"></a>node.js能用来做什么</h3><ul><li>Web服务API，比如REST</li><li>实时多人游戏</li><li>后端Web服务，譬如跨域、服务端的请求</li><li>基于Web的应用</li><li>多客户端的通信，如即时通信</li><li>本地应用程序等等</li></ul><h3 id="npm介绍"><a href="#npm介绍" class="headerlink" title="npm介绍"></a><strong>npm介绍</strong></h3><blockquote><p>1.npm是随Node.js一起安装的包管理工具，看名字就知道是用来对包进行管理的<br>2.npm允许用户从npm服务器下载和安装第三包进行使用，用户也可以自己编写包进行上传一起丰富这个庞大的生态系统</p></blockquote><ol><li>是全球最大的开源库生态系统<blockquote><p>对于包：在Node.js中一个js文件就可以成为一个模块，将多个模块放在一起完成特定功能就可以看作成一个包，使用npm包管理工具可以在工程中快捷的安装、引入自己需要的包,在安装过程中npm还会将目标包中所依赖的其他包一并下载</p></blockquote></li><li>类似Java语法中的maven，gradle，python中的pip</li></ol><blockquote><p>命令使用</p></blockquote><pre class=" language-JavaScript"><code class="language-JavaScript">// 查看npm的命令列表npm help// 查看npm的版本npm -v// 查看npm的配置（设置全局模块，镜像源，缓存，都可以进行查看是否成功）npm config ls -l</code></pre><blockquote><p>初始化命令</p><ul><li>将当前目录作为工作空间  </li><li>在当前目录下创建一个package.json文件，用来记录名字，版本，依赖等信息。 </li><li>不加-y参数在创建package.json过程中会让你设置名字，版本，依赖等信息，加上后不会提问会直接默认创建</li></ul></blockquote><pre class=" language-JavaScript"><code class="language-JavaScript">npm initnpm init -y</code></pre><p>下面是加上-y后默认创建的package.json中的内容<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%B8%80%E7%AF%87(Node.js%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0)/10-%E9%BB%98%E8%AE%A4%E5%88%9B%E5%BB%BA%E7%9A%84packagejson%E6%96%87%E4%BB%B6.png" alt="默认内容"></p><blockquote><p>安装第三方包（install）</p><ul><li>这是npm非常重要也是使用得非常多的功能  </li><li>安装包时会将包下载至node_modules目录中(不存在会自动创建)  </li><li>安装时候不加-g参数会默认安装在当前目录下</li><li>安装的时候加-g参数则是全局安装，会安装至设置的node_global中</li></ul></blockquote><pre class=" language-JavaScript"><code class="language-JavaScript">// 安装本地包npm install 包名// 安装全局包 npm install 包名 -g// --save参数(加上此参数会将包信息写进package.json的dependencies中)npm install 包名 --save// --save-dev参数(加上此参数会将包信息添加到package.json的devDependencies中)npm install 包名 --save-dev</code></pre><blockquote><p>dependencies与devDependenices  </p><ul><li>都是指定项目依赖的包</li><li>dependencies——这些包是需要发布到生产环境中去的，devDependencies——这些包只用于开发环境，不用于生产环境<br>【eg】:一个项目需要依赖于JQuery,没有这个包依赖运行就会报错，这时候需要将依赖写进dependenies。如果这个包只在开发测试过程中需要，上线后就不需要了，就写进devDependencies中</li></ul></blockquote><blockquote><p>卸载包(uninstall)【和安装相反其他一样】</p></blockquote><pre class=" language-JavaScript"><code class="language-JavaScript">// 卸载本地包npm uninstall 包名// 卸载全局包 npm uninstall 包名 -g// --save参数(加上此参数会将包信息写进package.json的dependencies中)npm uninstall 包名 --save// --save-dev参数(加上此参数会将包信息添加到package.json的devDependencies中)npm uninstall 包名 --save-dev</code></pre><p>npm学习网站：<a href="https://www.runoob.com/nodejs/nodejs-npm.html">https://www.runoob.com/nodejs/nodejs-npm.html</a></p><h2 id="node-js安装和配置"><a href="#node-js安装和配置" class="headerlink" title="node.js安装和配置"></a>node.js安装和配置</h2><blockquote><p><font face="Helvetica">安装Node.js此处介绍两种安装方式，一是通过msi程序引导安装，另一种是通过下载压缩包自己配置环境变量进行安装</font></p></blockquote><blockquote><p>新版的node.js自带npm，安装时会同时安装npm</p></blockquote><h3 id="引导程序安装："><a href="#引导程序安装：" class="headerlink" title="引导程序安装："></a><strong>引导程序安装</strong>：</h3><ul><li><p>第一步：在<a href="https://nodejs.org/zh-cn/">官网</a>下载node的msi程序安装文件。<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%B8%80%E7%AF%87(Node.js%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0)/1-%E5%AE%98%E7%BD%91%E7%95%8C%E9%9D%A2.png" alt="官网界面"></p></li><li><p>第二步:双击进入安装过程,正常情况下下一步就行了<br>其中有两个过程需要注意<br>  第一：安装模块的选择<br>  <img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%B8%80%E7%AF%87(Node.js%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0)/2-%E5%AE%89%E8%A3%85%E9%80%89%E6%8B%A9.png"><br>  Node.js runtime是Node.js的核心模块<br>  npm package manager是包管理工具<br>  Online documentation shortcut是相关介绍文档<br>  Add to PATH是将node和npm添加到环境变量<br>  <strong>默认就行</strong><br>  第二：<br>  <img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%B8%80%E7%AF%87(Node.js%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0)/3-%E5%AE%89%E8%A3%85%E9%80%89%E6%8B%A9.png"><br>  勾选后会自动安装2个工具，Python 2和Visual Studio构建工具,这两个构建工具是因为一些npm模块需要使用C/C++编译，如果想要编译这些模块则需要安装，不安装的话后续碰到这些模块会出问题，建议直接勾选避免不必要的麻烦，虽然后续可以手动安装</p><blockquote><p>关于这两个构建工具勾选后，Node.js安装完成后会跳出powershell窗口，光标一直会闪，不要关闭，会等一段时间才进行下载，如果安装失败就只能手动安装了。不过使用Node.js不是很多的话不安装也没什么大的影响。</p></blockquote></li><li><p>第三步:如果安装时勾选了Add to PATH，环境就已经安装完毕了，打开cmd窗口输入”node -v”和”npm -v”命令进行检测，如下图所示就是已经安装成功了<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%B8%80%E7%AF%87(Node.js%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0)/4-%E6%B5%8B%E8%AF%95%E5%AE%89%E8%A3%85.png" alt="测试图片"></p><h3 id="压缩包安装"><a href="#压缩包安装" class="headerlink" title="压缩包安装"></a><strong>压缩包安装</strong></h3><blockquote><p>通过下载压缩包进行安装（这是我最喜欢的方式）</p></blockquote></li><li><p>第一步：还是在<a href="https://nodejs.org/zh-cn/download/">官网</a>下载压缩包<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%B8%80%E7%AF%87(Node.js%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0)/5-%E5%8E%8B%E7%BC%A9%E5%8C%85%E4%B8%8B%E8%BD%BD.png" alt="下载界面"></p></li><li><p>下载解压后和第一种方式安装的内容是一样的</p></li><li><p>第二步：配置环境变量<br>将解压的目录路径添加到用户变量的path中去<br>如图：<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%B8%80%E7%AF%87(Node.js%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0)/6-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE.png" alt="环境变量"><br>到这里基本工作已经做完，在cmd中输入”node -v”和”npm -v”此时应该是已经能够正常显示的</p></li></ul><h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a><strong>其他配置</strong></h3><blockquote><p>上述两种方式中无论选择哪种方式都是一样的，安装好后就进行接下来的操作</p></blockquote><blockquote><p>在后续使用npm命令(如npm install 模块名 -g)[-g 是代表全局安装的参数，具体可以看npm的相关介绍]会默认安装在【C:\Users\用户名\AppData\Roaming\npm】占用C盘空间,接下来是设置为自定义路径 </p></blockquote><blockquote><p>此处是以第二种方式进行说明</p></blockquote><ul><li>配置npm安装模块时全局模块以及缓存cache的路径<ul><li>在安装的node文件下新建node_cache和node_global两个文件夹<br>然后在cmd中输入以下两行命令  <pre><code>npm config set prefix &quot;node_global路径&quot;  npm config set cache &quot;node_cache路径&quot;</code></pre><img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%B8%80%E7%AF%87(Node.js%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0)/7-%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84%E6%9B%B4%E6%94%B9.png" alt="命令输入"></li></ul></li><li>配置安装模块的镜像源  <ul><li>在cmd中使用命令 <pre><code>npm config set registry https://registry.npm.taobao.org --global</code></pre></li><li>进行验证,命令：npm config ls -l<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/%E7%AC%AC%E4%B8%80%E7%AF%87(Node.js%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0)/8--%E6%9B%B4%E6%8D%A2%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F.png" alt="更换配置"></li></ul></li></ul><blockquote><p>之所以更换镜像源是因为npm的默认镜像源是在国外，由于网络的原因会安装失败，因此更换为淘宝的镜像源(<a href="https://registry.npm.taobao.org/&quot;">https://registry.npm.taobao.org/&quot;</a>) </p></blockquote><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="JS介绍"><a href="#JS介绍" class="headerlink" title="JS介绍"></a>JS介绍</h3><blockquote><p>此处只做简单介绍，毕竟此文章是作为知识广度的扩充</p></blockquote><blockquote><p>建议仔细阅读阮一峰的JavaScript诞生记<br><a href="http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html">http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html</a><br>知乎上关于JavaScript是什么<br><a href="https://www.zhihu.com/question/19813265">https://www.zhihu.com/question/19813265</a></p></blockquote><p>JavaScript是什么呢？下面开始扯名词</p><ul><li>JavaScript是一种轻量级的解释型脚本语言<blockquote><p>何为脚本语言  </p><ol><li>介于标记语言和编程语言之间的一种语言</li><li>灵活，语法和结构规则没有编程语言那么严谨和复杂，学习和使用相对简单</li><li>属于解释性语言(相对的是编译型语言)，由解释器进行解释  </li></ol><ul><li>注：现在很多脚本语言已经不止停留于编写简单的用户命令序列的指令，可以编写更为复杂的程序， <strong>脚本语言和编程语言没有明显的界限和规定</strong></li></ul></blockquote></li><li>是一门基于原型，函数先行的语言</li></ul><blockquote><p>基于原型的粗略理解就是JavaScript中是没有Class的，而是直接使用对象。</p></blockquote><blockquote><p>阮一峰JavaScript诞生记部分内容：  </p><ul><li>Javascript中没有类(Class)的概念，因此也就没有”子类”和”父类”的概念，存在一种”原型链”模式来实现继承 <strong>JS虽然没有类，但是存在继承</strong>  </li><li>历史诞生记：  <ol><li>JS是由网景公司(Netscape)的工程师Brendan Eich负责开发  </li><li>诞生的原因：在JS出现之前，浏览器只能用来进行浏览，无法与使用者进行互动，网景公司需要一种网页脚本实现浏览器与网页的互动</li><li>在此时1994年，面向对象编程最兴盛时期，Sun公司与网景结成联盟，允许Java程序以applet（小程序）的形式，直接在浏览器中运行。但是现在Java和JavaScript没有任何关系</li><li>设计之初要求该语言要简单，易于上手</li></ol></li><li>最终JS涵盖了两种语言风格：(简化)函数式编程和(简化)面向对象编程</li><li>JS构造对象，没有类的概念，所以构造对象时new后面直接跟构造函数，例如：<br>  function DOG(name) {<pre><code>  this.name = name;</code></pre>  }</li><li>对于其他的例如prototype和__proto__如果想要学习JS需要找其他资料</li></ul></blockquote><ul><li>浏览器中的JavaScript不提供对内存或CPU的底层访问，IO操作等，进行这些操作或者更复杂的操作需要借助Node.js等运行环境</li></ul><blockquote><p>吐糟：第一篇博客，还有许多地方需要改进，目前只能自己作为日后回顾时学习。(ps：前面的几篇都是搭建博客时测试用的草稿一样，不能算博客，本来想删的，思来想去还是留着吧，当个挂件)</p></blockquote><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>其他大佬的文章：<br>node.js学习：<a href="https://www.w3cschool.cn/nodejs/node-js-npm.html">https://www.w3cschool.cn/nodejs/node-js-npm.html</a><br>网址：<a href="https://juejin.cn/post/6844903906116370445">https://juejin.cn/post/6844903906116370445</a><br>Node.js:<a href="https://segmentfault.com/a/1190000006121183">https://segmentfault.com/a/1190000006121183</a><br>V8引擎：<a href="https://zhuanlan.zhihu.com/p/27628685">https://zhuanlan.zhihu.com/p/27628685</a><br>V8引擎如何工作：<a href="https://blog.fundebug.com/2019/07/16/how-does-v8-work/">https://blog.fundebug.com/2019/07/16/how-does-v8-work/</a><br>npm命令：<a href="https://www.cnblogs.com/hongdada/p/9144668.html">https://www.cnblogs.com/hongdada/p/9144668.html</a><br>Node.js安装:<a href="https://www.cnblogs.com/liangxfng/p/12675115.html">https://www.cnblogs.com/liangxfng/p/12675115.html</a><br><a href="https://zhuanlan.zhihu.com/p/77594251">https://zhuanlan.zhihu.com/p/77594251</a></p>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> 前端 </tag>
            
            <tag> 广度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环境配置</title>
      <link href="3%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>3%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p> <font color=white><strong>关于C盘索引路径和软件安装的插件:当卸载软件时,软件的这些文件不一定会删除,再次安装时可以直接读取和使用,因此人为改变后卸载软件最好及时删除或者下次重新安装时记得更改配置文件</strong></font></p><h3 id="Intellij-IDEA-2019-3-1"><a href="#Intellij-IDEA-2019-3-1" class="headerlink" title="Intellij IDEA 2019.3.1"></a>Intellij IDEA 2019.3.1</h3><h5 id="一-更改默认插件安装位置"><a href="#一-更改默认插件安装位置" class="headerlink" title="(一)更改默认插件安装位置"></a>(一)更改默认插件安装位置</h5><ul><li><p>Intellij IDEA安装在F盘Self_installing_Software文件夹中(这里)</p></li><li><p>idea自带的插件在idea安装目录的plugins目录中</p><blockquote><p>F:\Self_installing_Software\IntelliJ IDEA\IntelliJ IDEA 2019.3.1\plugins</p></blockquote></li><li><p>idea用户安装(非自带)的插件,默认在用户的 <strong>C:\Users\计算机名.IntelliJIdea2019.3\config\plugins</strong> 目录下</p><blockquote><p>C:\Users\Lenovo.IntelliJIdea2019.3\config\plugins</p></blockquote></li><li><p>听说2020年的Intellij IDEA安装的插件默认在:<br>C:\Users\Administrator\AppData\Roaming\JetBrains\IntelliJIdea2020.1\plugins</p></li><li><p>重点:更换默认安装目录</p><ol><li><p>进入idea的安装目录,找到“idea.properties”文件；</p></li><li><p>修改图中所示的两个地方,(相对路径和绝对路径均可),后面的为路径,其中config/plugins和system文件夹为独立创建的<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/5-1%E6%9B%B4%E6%8D%A2%E8%B7%AF%E5%BE%84.png"></p><ul><li>其中plugins路径为更改后的插件安装路径</li><li>system文件夹估计时运行时读取和生成配置的文件</li></ul></li><li><p>将C盘中两个文件夹中的文件拷贝到对应的文件即可,关闭重启idea</p></li></ol></li><li><p>可参考网址:</p><blockquote><p><a href="https://www.cnblogs.com/xiaostudy/p/12452139.html">https://www.cnblogs.com/xiaostudy/p/12452139.html</a><br><a href="https://www.bmqy.net/1773.html">https://www.bmqy.net/1773.html</a></p></blockquote></li><li><p>更改软件索引网址可参考:(譬如Intellij IDEA的默认索引路径为C:\Users\用户.IntelliJIdea)</p><blockquote><p><a href="https://www.cnblogs.com/appleat/p/10097048.html">https://www.cnblogs.com/appleat/p/10097048.html</a></p></blockquote></li></ul><hr><h5 id="二-主题配置"><a href="#二-主题配置" class="headerlink" title="(二)主题配置"></a>(二)主题配置</h5><h6 id="1-idea设置代码彩色高亮显示"><a href="#1-idea设置代码彩色高亮显示" class="headerlink" title="1.idea设置代码彩色高亮显示"></a>1.idea设置代码彩色高亮显示</h6><ul><li><p><strong>设置主题</strong><br>1.下载主题(见附录) 代码高亮主题选择了SublimeMonoKai.jar</p><blockquote><p>代码高亮主题网址(主要是代码区域)<br><a href="https://github.com/guobinhit/intellij-idea-tutorial/tree/master/resources/idea-theme">https://github.com/guobinhit/intellij-idea-tutorial/tree/master/resources/idea-theme</a><br>  全局主题网址:<br><a href="http://color-themes.com/?view=index">http://color-themes.com/?view=index</a></p></blockquote><p>2.导入主题:File–&gt;Import Settings–&gt;选择下载的主题的jar包<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/5-1%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E4%B8%BB%E9%A2%98.jpg"><br>3.配置主题:File–&gt;Setting–&gt;Color Scheme–&gt;右边Scheme选择主题即可<br>  <img src="https://remmeiko.gitee.io/img-bed/boke-img/5-2%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E4%B8%BB%E9%A2%98.jpg"></p></li><li><p><strong>删除主题</strong><br>1.主题配置文件的位置默认在C:\Users\计算机名.IntelliJIdea2018.2\config\colors目录下，找到相应的文件，并将其删除，重启 IntelliJ IDEA 后生效。<br>  <img src="https://remmeiko.gitee.io/img-bed/boke-img/5-3%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E4%B8%BB%E9%A2%98.jpg"></p></li><li><p>参考网址:</p><blockquote><p><a href="https://blog.csdn.net/Liu_xud/article/details/84190828">https://blog.csdn.net/Liu_xud/article/details/84190828</a><br><a href="https://blog.csdn.net/macSun_jh/article/details/81294235">https://blog.csdn.net/macSun_jh/article/details/81294235</a><br><a href="https://blog.csdn.net/qq_35246620/article/details/79056530">https://blog.csdn.net/qq_35246620/article/details/79056530</a></p></blockquote></li></ul><h6 id="2-设置全局主题"><a href="#2-设置全局主题" class="headerlink" title="2.设置全局主题"></a>2.设置全局主题</h6><ul><li>可以采取和上述一致的方法进行设置,也可以采取下述方法进行设置</li><li><strong>使用idea插件设置</strong> –&gt;<strong>Material Theme UI</strong>(把IDEA变得更加美观)</li><li>*步骤:** File–&gt;Settings–&gt;Plugins–&gt;搜索Material Theme UI–&gt;安装–&gt;重启</li><li>具体搭配很多样化,需要自行配置,下面是效果图(下面附带有自定义背景图):<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/5-4%E9%85%8D%E7%BD%AE%E4%B8%BB%E9%A2%98.jpg"></li><li>参考网址:(网址中还有一种通过网站下载插件再安装的方法)<blockquote><p><a href="https://blog.csdn.net/h13245/article/details/104847491/">https://blog.csdn.net/h13245/article/details/104847491/</a></p></blockquote></li></ul><h6 id="3-自定义背景图片"><a href="#3-自定义背景图片" class="headerlink" title="3.自定义背景图片"></a>3.自定义背景图片</h6><ul><li>默认背景是无背景设置</li><li>大致步骤<ul><li>设置搜索Set Backgroud Image</li><li>选择右边出现的黄色字体右键设置快捷键(Ctrl+Alt+0)(建议设置)</li><li>在弹出来是设置中便可以设置背景,附有一些相关设置</li></ul></li><li>设置网址:<blockquote><p><a href="https://blog.csdn.net/qq_42183409/article/details/90612098">https://blog.csdn.net/qq_42183409/article/details/90612098</a></p></blockquote></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Intellij IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Intellij IDEA </tag>
            
            <tag> 界面外观 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程问题</title>
      <link href="2%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98/"/>
      <url>2%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="编程问题"><a href="#编程问题" class="headerlink" title="编程问题"></a>编程问题</h1><h3 id="一-IDEA-错误-找不到或无法加载主类-解决方法"><a href="#一-IDEA-错误-找不到或无法加载主类-解决方法" class="headerlink" title="(一) IDEA 错误: 找不到或无法加载主类 解决方法"></a>(一) IDEA 错误: 找不到或无法加载主类 解决方法</h3><ul><li>问题描述:运行程序过程中报上述错误</li><li>可能原因:未能成功编译或者缓存问题</li><li>大致步骤<ul><li>菜单–&gt;Build–&gt;Rebuild Prodject</li><li>清除缓存在重构:菜单–&gt;File–&gt;Invalidate Caches/Restart 选择Invalidate and Restart或者只是Invalidate，清除掉缓存，然后Rebuild Project</li></ul></li><li>解决网址:<blockquote><p><a href="https://blog.csdn.net/kevinxxw/article/details/88647617">https://blog.csdn.net/kevinxxw/article/details/88647617</a></p></blockquote></li></ul><hr><h3 id="二-Intellij-IDEA-配置Maven项目环境"><a href="#二-Intellij-IDEA-配置Maven项目环境" class="headerlink" title="(二) Intellij IDEA 配置Maven项目环境"></a>(二) Intellij IDEA 配置Maven项目环境</h3><h6 id="Intellij-IDEA-配置Maven环境"><a href="#Intellij-IDEA-配置Maven环境" class="headerlink" title="Intellij IDEA 配置Maven环境:"></a>Intellij IDEA 配置Maven环境:</h6><ul><li><p>1.下载apache-maven文件,网址:</p><blockquote><p><a href="http://maven.apache.org/index.html">http://maven.apache.org/index.html</a></p></blockquote></li><li><p>2.解压,配置环境变量,高级设置中…</p><blockquote><p>a.MAVEN_HOME:D:\server\maven\apache-maven-3.5.0<br>b.PATH:%MAVEN_HOME%\bin;</p></blockquote></li><li><p>3.cmd输入mvn -v出现下列信息,则配置成功<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/1-mvn.jpg"></p></li><li><p>4.修改Maven仓库路径</p></li></ul><ul><li>在下载的Maven的路径中(F:\Self_installing_Software\18_Maven\apache-maven-3.6.3-bin\apache-maven-3.6.3-bin\apache-maven-3.6.3\conf)找到setting.xml文件,<br>设置如下:<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;&lt;pluginGroups /&gt;&lt;proxies /&gt;&lt;servers /&gt;&lt;localRepository&gt;D:/server/maven/repository&lt;/localRepository&gt;&lt;mirrors&gt;&lt;mirror&gt;  &lt;id&gt;alimaven&lt;/id&gt;  &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;  &lt;name&gt;aliyun maven&lt;/name&gt;  &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt;  &lt;id&gt;alimaven&lt;/id&gt;  &lt;name&gt;aliyun maven&lt;/name&gt;  &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;  &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt;&lt;mirror&gt;  &lt;id&gt;central&lt;/id&gt;  &lt;name&gt;Maven Repository Switchboard&lt;/name&gt;  &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt;  &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt;&lt;mirror&gt;  &lt;id&gt;repo2&lt;/id&gt;  &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;  &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;  &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt;  &lt;id&gt;ibiblio&lt;/id&gt;  &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;  &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;  &lt;url&gt;http://mirrors.ibiblio.org/pub/mirrors/maven2/&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt;  &lt;id&gt;jboss-public-repository-group&lt;/id&gt;  &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;  &lt;name&gt;JBoss Public Repository Group&lt;/name&gt;  &lt;url&gt;http://repository.jboss.org/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt;  &lt;id&gt;google-maven-central&lt;/id&gt;  &lt;name&gt;Google Maven Central&lt;/name&gt;  &lt;url&gt;https://maven-central.storage.googleapis.com  &lt;/url&gt;  &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt;&lt;!-- 中央仓库在中国的镜像 --&gt;&lt;mirror&gt;  &lt;id&gt;maven.net.cn&lt;/id&gt;  &lt;name&gt;oneof the central mirrors in china&lt;/name&gt;  &lt;url&gt;http://maven.net.cn/content/groups/public/&lt;/url&gt;  &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt;&lt;/mirrors&gt;&lt;/settings&gt;</code></pre>至此maven配置完毕,设置外部的 maven,其实Intellij自带有maven.<br>Idea自带了apache maven，默认使用的是内置maven，所以我们可以配置全局setting，来调整一下配置，比如远程仓库地址，本地编译环境变量等。</li></ul><ul><li><p>5.接下来是设置Intellj,打开Intellij IDEA,选择右下角的Configure设置,选择setting设置<br>ps:在不开任何项目的前提下设置是全局设置<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/2-Maven%E9%85%8D%E7%BD%AE.jpg"><br><img src="https://remmeiko.gitee.io/img-bed/boke-img/4-maven%E9%85%8D%E7%BD%AE.jpg"></p></li><li><p>6.上张图中右下角三处设置为下载的位置和配置</p></li><li><p>7.如果配置了本地apache-maven setting.xml 中的软件源，这步骤可以忽略,配置镜像源<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/4-maven%E9%85%8D%E7%BD%AE.png"></p></li><li><p>具体学习网址:(两网址参考对比配置环境)</p><blockquote><p><a href="https://blog.csdn.net/qq_32588349/article/details/51461182">https://blog.csdn.net/qq_32588349/article/details/51461182</a><br><a href="https://zhuanlan.zhihu.com/p/28133184">https://zhuanlan.zhihu.com/p/28133184</a></p></blockquote></li><li><p>附带其他相关网址:</p><blockquote><p><a href="https://www.tutorialspoint.com/maven/maven_environment_setup.htm">https://www.tutorialspoint.com/maven/maven_environment_setup.htm</a></p></blockquote></li><li><p>配置完毕创建第一个Maven项目参考网址:</p><blockquote><p><a href="https://cloud.tencent.com/developer/article/1105419">https://cloud.tencent.com/developer/article/1105419</a><br><a href="https://ken.io/note/java-quickstart-idea-maven-console">https://ken.io/note/java-quickstart-idea-maven-console</a></p></blockquote></li></ul><h3 id="三-Eclipse配置Maven详细教程"><a href="#三-Eclipse配置Maven详细教程" class="headerlink" title="(三) Eclipse配置Maven详细教程"></a>(三) Eclipse配置Maven详细教程</h3><ul><li>描述:Maven的配置和Intellij中的一致,其余参考网址配置</li><li>参考网址:<blockquote><p><a href="https://blog.csdn.net/wcc27857285/article/details/81812304">https://blog.csdn.net/wcc27857285/article/details/81812304</a></p></blockquote></li></ul><h3 id="四-通过maven添加Jar包"><a href="#四-通过maven添加Jar包" class="headerlink" title="(四) 通过maven添加Jar包"></a>(四) 通过maven添加Jar包</h3><ul><li><p>maven对Java项目管理最为方便一点便在于对引入包的管理,在pom.xml中添加代码,由代码去拉取插件和jar包添加到项目</p><h6 id="步骤"><a href="#步骤" class="headerlink" title="步骤:"></a>步骤:</h6></li><li><p>1.进入官网</p><blockquote><p><a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p></blockquote></li><li><p>2.输入你需要引入的包,例如jsoup,点击搜索,会显示对应的包,点击包<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/2-1maven%E5%BC%95%E5%85%A5%E5%8C%85.jpg"></p></li><li><p>3.选择需要的对应的版本,点击确认的框<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/2-2maven%E5%BC%95%E5%85%A5%E5%8C%85.jpg"></p></li><li><p>4.复制包的坐标<br><img src="https://remmeiko.gitee.io/img-bed/boke-img/2-3maven%E5%BC%95%E5%85%A5%E5%8C%85.jpg"></p></li><li><p>5.复制至maven中的pom.xml中</p></li></ul><hr><h3 id="五-java操作Excel数据"><a href="#五-java操作Excel数据" class="headerlink" title="(五)java操作Excel数据"></a>(五)java操作Excel数据</h3><h5 id="1-运行错误"><a href="#1-运行错误" class="headerlink" title="1.运行错误"></a>1.运行错误</h5><ul><li>详细描述:<pre><code>Exception in thread &quot;main&quot; java.lang.IncompatibleClassChangeError: Found interface org.apache.poi.util.POILogger, but class was expected</code></pre></li><li>原因:jar包版本不一致(pom.xml中poi版本不一致)ps:(也可能是jar包冲突,看到有博客介绍到)</li><li>解决:版本设置一致(<strong>version保证都是同一版,这里是4.1.2</strong>)<pre><code>&lt;dependency&gt;  &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;  &lt;artifactId&gt;poi&lt;/artifactId&gt;  &lt;version&gt;4.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;  &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;  &lt;version&gt;4.1.2&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li>参考网址:<blockquote><p><a href="https://www.dazhuanlan.com/2019/09/08/1f9aa2a35c8e/">https://www.dazhuanlan.com/2019/09/08/1f9aa2a35c8e/</a></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Intellij IDEA </tag>
            
            <tag> Eclipse </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="hello-world/"/>
      <url>hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="博客前言"><a href="#博客前言" class="headerlink" title="博客前言"></a>博客前言</h2><ul><li><strong>RemMeiko的小屋，昏暗光芒下的独自取暖</strong><ul><li>分享点滴</li><li>分享随想</li><li>记录互联网中留下的足迹</li><li>投射我所期望的世界</li></ul></li></ul><p><strong>博客正在搭建中……(8.8.)</strong></p><blockquote><p>前两篇博客是在搭建博客时拿来测试使用的，我更愿称之为数据，不用太在意</p></blockquote><h1 id="弱小和无知从来不是生存的障碍-傲慢才是"><a href="#弱小和无知从来不是生存的障碍-傲慢才是" class="headerlink" title="弱小和无知从来不是生存的障碍,傲慢才是"></a><strong>弱小和无知从来不是生存的障碍,傲慢才是</strong></h1>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随手记 </tag>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>所思所想</title>
      <link href="%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/"/>
      <url>%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
